AWSTemplateFormatVersion: 2010-09-09

Description: Creates a ZooKeeper cluster

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: General Configuration
        Parameters:
          - IamPrefix
          - PermissionsBoundaryPolicyArn
          - ResourceSuffix

      - Label:
          default: ZooKeeper Configuration
        Parameters:
          - ZkInstanceType
          - ZkBinaryDownloadUrl

      - Label:
          default: Networking Configuration
        Parameters:
          - VpcId
          - VpcCidr
          - SubnetIds
          - S3PrefixListId

      - Label:
          default: Image Builder Configuration
        Parameters:
          - SemVer
          - ParentImage
          - ProxyServerAddress
          - NoProxyList
          - BypassGpgCheck
          - OutboundCidrIp

    ParameterLabels:
      IamPrefix:
        default: IAM Resource Prefix
      PermissionsBoundaryPolicyArn:
        default: Permissions Boundary Policy ARN
      ResourceSuffix:
        default: Resource Suffix
      ZkInstanceType:
        default: ZooKeeper Instance Type
      ZkBinaryDownloadUrl:
        default: ZooKeeper Binary Download URL
      VpcId:
        default: VPC ID
      VpcCidr:
        default: VPC CIDR
      SubnetIds:
        default: Subnet IDs
      S3PrefixListId:
        default: S3 Prefix List ID
      SemVer:
        default: Semantic Version
      ParentImage:
        default: Parent Image
      ProxyServerAddress:
        default: Proxy Server Address
      NoProxyList:
        default: No Proxy List
      BypassGpgCheck:
        default: Bypass GPG Check
      OutboundCidrIp:
        default: Outbound CIDR

Parameters:
  IamPrefix:
    Type: String
    Description: Required prefix for IAM resources
    Default: AFC2S
    AllowedValues: [AFC2S]
    ConstraintDescription: Must be "AFC2S"

  PermissionsBoundaryPolicyArn:
    Type: String
    Description: ARN of the policy that is used to set the permissions boundary for IAM resources
    AllowedPattern: ^arn:(aws|aws-us-gov|aws-iso-b|aws-iso):iam::(\d{12}|aws):policy/.*
    ConstraintDescription: Must be a valid IAM policy ARN

  ResourceSuffix:
    Type: String
    Description: >-
      Suffix added to the named AWS resources. It must start with a lowercase letter and contain
      only lowercase letters, numbers, and hyphens; its length cannot exceed 20.
    AllowedPattern: ^[a-z][a-z0-9-]{0,19}$
    ConstraintDescription: >
      Must start with a lowercase letter and contain only lowercase letters, numbers, and hyphens; its length cannot exceed 20.

  ZkInstanceType:
    Type: String
    Description: Instance type for ZooKeeper nodes
    Default: m5.xlarge
    AllowedPattern: ^[a-z0-9-]+\.[a-z0-9.-]+$
    ConstraintDescription: Must be a valid instance type

  ZkBinaryDownloadUrl:
    Type: String
    Description: Download URL for ZooKeeper binary
    Default: https://dlcdn.apache.org/zookeeper/zookeeper-3.8.4/apache-zookeeper-3.8.4-bin.tar.gz
    AllowedPattern: ^\S+$
    ConstraintDescription: Must be a valid URL

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: Select a VPC in which ZooKeeper nodes will be created. Note that the same VPC will be used by the image pipeline.
    AllowedPattern: \S+
    ConstraintDescription: Must select a VPC

  VpcCidr:
    Type: String
    Description: The CIDR of the VPC chosen above
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/([0-9]|[1-2][0-9]|3[0-2]))$
    ConstraintDescription: Must be a valid CIDR block

  SubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
    Description: Select subnets (from the VPC chosen above) in which ZooKeeper nodes will be created. Note that the first subnet will be used by the image pipeline.
    AllowedPattern: \S+
    ConstraintDescription: Must select a subnet

  S3PrefixListId:
    Type: String
    Description: S3 Prefix List ID (e.g. pl-7a3a1b0f)
    AllowedPattern: ^pl-([a-f0-9]{8}|[a-f0-9]{17})$
    ConstraintDescription: Must be a valid S3 Prefix List ID

  SemVer:
    Type: String
    Description: >
      Semantic version of the ZooKeeper Image Recipe and other associated resources.
      Increment this when updating the parent image below or any associated resources in the template itself.
      The format is <major>.<minor>.<patch> where each component is an integer (e.g. 1.0.0).
    Default: "1.0.0"
    AllowedPattern: ^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)$
    ConstraintDescription: Must be a valid semantic version (e.g., 1.0.0)

  ParentImage:
    Type: AWS::EC2::Image::Id
    Description: Parent (or base) image for the image recipe, in either an Image ARN or an AMI ID format.

  ProxyServerAddress:
    Type: String
    Description: Address of the proxy server for outbound internet access. It can be an http or IP address. The port is fixed at 3128.
    AllowedPattern: ^(?!.*(:[0-9]{1,5}))(https?://([a-zA-Z0-9-_.]+)|((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])))$
    ConstraintDescription: Must be a valid http or IP address, without the port number

  NoProxyList:
    Type: String
    Description: A comma-separated list of addresses that should bypass the proxy server. These can be either http or IP addresses.
    Default: 169.254.169.254,s3.us-gov-west-1.amazonaws.com,ssm.us-gov-west-1.amazonaws.com,ssmmessages.us-gov-west-1.amazonaws.com,ec2messages.us-gov-west-1.amazonaws.com

  BypassGpgCheck:
    Type: String
    Description: Select "true" to bypass GPG check for SSM Agent installation file; otherwise, select "false"
    Default: "false"
    AllowedValues: ["true", "false"]
    ConstraintDescription: Must be either "true" or "false"

  OutboundCidrIp:
    Type: String
    Description: Outbound CIDR block for ImageBuilder instances
    Default: 0.0.0.0/0
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/([0-9]|[1-2][0-9]|3[0-2]))$
    ConstraintDescription: Must be a valid CIDR block

Conditions:
  IsLCK: !Equals [!Ref "AWS::Partition", aws-iso-b]
  IsDCA: !Equals [!Ref "AWS::Partition", aws-iso]
  IsHighSide: !Or [Condition: IsLCK, Condition: IsDCA]
  IsLowSide: !Not [Condition: IsHighSide]

Resources:
  ZkImageBuilderPipeline:
    Type: AWS::ImageBuilder::ImagePipeline
    Properties:
      Name: !Sub zookeeper-image-pipeline-${ResourceSuffix}
      Status: ENABLED
      EnhancedImageMetadataEnabled: true
      ImageRecipeArn: !Ref ZkImageRecipe
      DistributionConfigurationArn: !Ref ZkImageBuilderDistroConfig
      ImageScanningConfiguration:
        ImageScanningEnabled: false # Enable it if Amazon Inspector is activated
      ImageTestsConfiguration:
        ImageTestsEnabled: true
      InfrastructureConfigurationArn: !Ref ZkInfraConfig
      # This Role is for the workflow
      # ExecutionRole: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/imagebuilder.amazonaws.com/AWSServiceRoleForImageBuilder
      # Workflows:
      #   - WorkflowArn: !GetAtt BuildWorkflow.Arn

  ZkImageRecipe:
    Type: AWS::ImageBuilder::ImageRecipe
    Properties:
      Name: !Sub zookeeper-image-recipe-${ResourceSuffix}
      Version: !Ref SemVer
      ParentImage: !Ref ParentImage
      WorkingDirectory: "/tmp"
      Components:
        - ComponentArn: !Sub arn:${AWS::Partition}:imagebuilder:${AWS::Region}:aws:component/update-linux/x.x.x
        - !If
          - IsLowSide
          - ComponentArn: !Sub arn:${AWS::Partition}:imagebuilder:${AWS::Region}:aws:component/aws-cli-version-2-linux/x.x.x
          - !Ref AWS::NoValue
        - ComponentArn: !Ref ZkBuildComponent
      # BlockDeviceMappings:
      #   - DeviceName: String
      #     Ebs:
      #       DeleteOnTermination: true
      #       Encrypted: true
      #       KmsKeyId: alias/aws/ebs # The default AWS managed key
      #       Iops: 100 # The range is 100-64000
      #       SnapshotId: String
      #       VolumeType: gp3 # standard | io1 | io2 | gp2 | gp3 | sc1 | st1
      #       Throughput: 125 # For gp3 volumes only; the range is 125â€“1000 MiB/s
      #       VolumeSize: 30 # The range is 1-16000
      #     NoDevice: "" # Enter an empty string to remove a mapping from the parent image.
      #     VirtualName: String # Manages the instance ephemeral devices.
      AdditionalInstanceConfiguration:
        SystemsManagerAgent:
          UninstallAfterBuild: false
        # If overriding the user data, add commands to install SSM, unless it is pre-installed on the base image.
        UserDataOverride:
          Fn::Base64: !Sub |
            #!/bin/bash

            cat >/etc/environment <<EOF
            HTTP_PROXY=${ProxyServerAddress}:3128
            HTTPS_PROXY=${ProxyServerAddress}:3128
            NO_PROXY=${NoProxyList}
            http_proxy=${ProxyServerAddress}:3128
            https_proxy=${ProxyServerAddress}:3128
            no_proxy=${NoProxyList}

            AWS_DEFAULT_REGION=${AWS::Region}
            AWS_REGION=${AWS::Region}
            EOF

            source /etc/environment

            mkdir -p /etc/systemd/system/amazon-ssm-agent.service.d
            cat > /etc/systemd/system/amazon-ssm-agent.service.d/proxy.conf <<EOF
            [Service]
            EnvironmentFile=/etc/environment
            EOF

            cat >> /etc/yum.conf <<EOF
            proxy=$https_proxy
            EOF

            # Install SSM Agent
            BYPASS_GPG=$([ ${BypassGpgCheck} = "true" ] && echo "--nogpgcheck" || echo "")
            ARCH=$(arch)
            if [ "$ARCH" = "arm64" ]; then
                yum install -y https://s3.${AWS::Region}.${AWS::URLSuffix}/amazon-ssm-${AWS::Region}/latest/linux_arm64/amazon-ssm-agent.rpm $BYPASS_GPG
            else # x86_64
                yum install -y https://s3.${AWS::Region}.${AWS::URLSuffix}/amazon-ssm-${AWS::Region}/latest/linux_amd64/amazon-ssm-agent.rpm $BYPASS_GPG
            fi

            # Restart SSM Agent
            systemctl daemon-reload
            systemctl restart amazon-ssm-agent

  ZkBuildComponent:
    Type: AWS::ImageBuilder::Component
    Properties:
      Name: !Sub zookeeper-build-component-${ResourceSuffix}
      Version: !Ref SemVer
      Platform: Linux
      SupportedOsVersions:
        - Red Hat Enterprise Linux 8
        - Red Hat Enterprise Linux 9
      KmsKeyId: !GetAtt KmsKey.Arn
      Data: !Sub |
        name: zookeeper-build
        description: zookeeper-build
        schemaVersion: 1.0
        phases:
          - name: build
            steps:
              - name: zookeeper-build
                action: ExecuteBash
                inputs:
                  commands:
                    - |
                      echo "Setting the script to exit on any error..."
                      set -e

                      working_dir=$(pwd)

                      # Create a function to check if a package is installed
                      is_installed() {
                          rpm -q "$1" >/dev/null 2>&1
                      }

                      echo "Gathering yum packages to install..."
                      # https://docs.redhat.com/en/documentation/red_hat_build_of_openjdk/11/html-single/installing_and_using_red_hat_build_of_openjdk_11_on_rhel/index
                      packages="java-21-openjdk wget"
                      packages_to_install=""
                      for package in $packages; do
                          if ! is_installed "$package"; then
                              packages_to_install="$packages_to_install $package"
                          else
                              echo "$package is already installed"
                          fi
                      done

                      if [ -n "$packages_to_install" ]; then
                          echo "Installing packages: $packages_to_install"
                          yum install -y $packages_to_install
                      else
                          echo "All required packages are already installed"
                      fi

                      user=root
                      user_home_dir=$(getent passwd "$user" | cut -d: -f6)
                      zk_tarfile=zookeeper.tar.gz

                      echo "Downloading ZooKeeper binary..."
                      wget -O "$zk_tarfile" ${ZkBinaryDownloadUrl}
                      echo "Extracting the downloaded file to $user_home_dir directory..."
                      tar -xzf "$zk_tarfile" -C "$user_home_dir"
                      echo "Deleting the downloaded file..."
                      rm -f "$zk_tarfile"

                      cat >> /etc/environment <<EOF

                      ZK_HOME=$(realpath -e "$user_home_dir"/apache-zookeeper-*-bin)
                      # ZOO_DATADIR_AUTOCREATE_DISABLE=1
                      EOF

                      # https://docs.aws.amazon.com/imagebuilder/latest/userguide/security-best-practices.html#post-build-cleanup
                      touch "$working_dir"/perform_cleanup
                      echo "SUCCESS!"

  ZkImageBuilderDistroConfig:
    Type: AWS::ImageBuilder::DistributionConfiguration
    Properties:
      Name: !Sub zookeeper-distro-config-${ResourceSuffix}
      Distributions:
        - Region: !Ref AWS::Region
          LaunchTemplateConfigurations:
            - AccountId: !Ref AWS::AccountId
              LaunchTemplateId: !Ref ZkAutoScalingGroupLaunchTemplate
              SetDefaultVersion: true # Set the specified Amazon EC2 launch template as the default launch template for the specified account.
          # AmiDistributionConfiguration:
          #   KmsKeyId: String

  ZkInfraConfig:
    Type: AWS::ImageBuilder::InfrastructureConfiguration
    Properties:
      Name: !Sub zookeeper-infra-config-${ResourceSuffix}
      InstanceMetadataOptions:
        HttpTokens: required
        HttpPutResponseHopLimit: 1
      InstanceProfileName: !Ref ZkImageBuilderInstanceProfile
      SubnetId: !Select [0, !Ref SubnetIds]
      SecurityGroupIds:
        - !Ref ZkImageBuilderSecurityGroup
      TerminateInstanceOnFailure: true
      InstanceTypes: [!Ref ZkInstanceType]
      SnsTopicArn: !Ref ZkImageBuilderNotificationTopic

  ZkImageBuilderInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub ${IamPrefix}-zk-imagebuilder-instance-profile-${ResourceSuffix}
      Roles: [!Ref ZkImageBuilderInstanceRole]

  ZkImageBuilderInstanceRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28 # Resource found with an explicit name, this disallows updates that require replacement of this resource
            reason: An explicit name is required
    Properties:
      RoleName: !Sub ${IamPrefix}-zk-imagebuilder-instance-role-${ResourceSuffix}
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
        # TODO: Scope it down if possible
        - !Sub arn:${AWS::Partition}:iam::aws:policy/EC2InstanceProfileForImageBuilder
      # Policies:
      #   - PolicyName: KMS_Policy
      #     PolicyDocument:
      #       Version: 2012-10-17
      #       Statement:
      #         - Effect: Allow
      #           Action: kms:Decrypt
      #           Resource: !GetAtt KmsKey.Arn
      # - PolicyName: S3_Policy
      #   PolicyDocument:
      #     Version: 2012-10-17
      #     Statement:
      #       - Sid: AllowGetObject
      #         Effect: Allow
      #         Action: s3:GetObject
      #         Resource: !Sub ${ZkRequiredFilesBucket.Arn}/*
      #       - Sid: AllowListBucket
      #         Effect: Allow
      #         Action: s3:ListBucket
      #         Resource: !Sub ${ZkRequiredFilesBucket.Arn}

  ZkImageBuilderSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for ZooKeeper ImageBuilder infrastructure
      VpcId: !Ref VpcId
      SecurityGroupEgress:
        - CidrIp: !Ref OutboundCidrIp
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          Description: Allow outbound traffic on 443
        - CidrIp: !Ref OutboundCidrIp
          IpProtocol: tcp
          FromPort: 3128
          ToPort: 3128
          Description: Allow outbound traffic on 3128

  ZkImageBuilderNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: ImageBuilder Event Notification
      KmsMasterKeyId: !GetAtt KmsKey.Arn

  ZkAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub zookeeper-asg-${ResourceSuffix}
      LaunchTemplate:
        LaunchTemplateId: !Ref ZkAutoScalingGroupLaunchTemplate
        Version: !GetAtt ZkAutoScalingGroupLaunchTemplate.DefaultVersionNumber
      # 3 is the minimum recommended size for a ZooKeeper ensemble (cluster)
      MinSize: 3
      MaxSize: 3
      MetricsCollection:
        - Granularity: 1Minute
      VPCZoneIdentifier: !Ref SubnetIds
      Tags:
        - Key: Name
          PropagateAtLaunch: false
          Value: !Sub zookeeper-asg-${ResourceSuffix}

  ZkAutoScalingGroupLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      TagSpecifications:
        - ResourceType: launch-template
          Tags:
            - Key: Name
              Value: !Sub zookeeper-launch-template-${ResourceSuffix}
      LaunchTemplateData:
        IamInstanceProfile:
          Arn: !GetAtt ZkNodeInstanceProfile.Arn
        ImageId: !Ref ParentImage
        InstanceType: !Ref ZkInstanceType
        BlockDeviceMappings:
          # TODO: Get the device name dynamically
          - DeviceName: /dev/sda1
            Ebs:
              VolumeSize: 100
              VolumeType: gp3
              # Encrypted: true
              # KmsKeyId: !Ref KmsKey
        Monitoring:
          Enabled: false
        DisableApiStop: true
        DisableApiTermination: true
        # EbsOptimized: true
        MetadataOptions:
          HttpPutResponseHopLimit: 1
          HttpTokens: required
        SecurityGroupIds:
          - !GetAtt ZkNodeSecurityGroup.GroupId
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub zookeeper-node-${ResourceSuffix}
          - ResourceType: volume
            Tags:
              - Key: Name
                Value: !Sub zookeeper-node-${ResourceSuffix}
          - ResourceType: network-interface
            Tags:
              - Key: Name
                Value: !Sub zookeeper-node-${ResourceSuffix}
        UserData:
          Fn::Base64: |
            #!/bin/bash

            echo "Setting the script to exit on any error..."
            set -e

            # Get total memory in MB
            total_mem_mb=$(grep MemTotal /proc/meminfo | awk '{print int($2/1024)}')
            # Calculate 75% of total memory
            heap_size_mb=$(( total_mem_mb * 75 / 100 ))
            # Add ZooKeeper heap settings to environment
            cat >> /etc/environment <<EOF
            JVMFLAGS="-Xms${heap_size_mb}m -Xmx${heap_size_mb}m"
            EOF

            # ZK maintenance: https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance
            # dataDir:
            # ZooKeeper will store the in-memory database snapshots in this dir and, unless specified otherwise, the transaction log of updates to the database.
            # "myid" file should be created inside this dir as well

            data_dir=/zookeeper/data
            mkdir -p $data_dir
            # Add data_dir to environment
            cat >> /etc/environment <<EOF
            ZK_DATA_DIR="$data_dir"
            EOF

            source /etc/environment

            cat > "$ZK_HOME"/conf/zoo.cfg <<EOF
            # unit of time (in milliseconds)
            tickTime=2000
            # limits the length of time the ZooKeeper servers in quorum have to connect to a leader (tickTime * 5)
            initLimit=10
            # limits how far out of date a server can be from a leader (tickTime * 2)
            syncLimit=5
            clientPort=2181
            standaloneEnabled=false
            # enables dynamic reconfiguration feature
            reconfigEnabled=true
            dynamicConfigFile=$ZK_HOME/conf/zoo.cfg.dynamic
            dataDir=$ZK_DATA_DIR
            # Purge task interval in hours; default (0) disables it
            autopurge.purgeInterval=24
            # The number of snapshots to retain in dataDir
            autopurge.snapRetainCount=30

            # secureClientPort=
            # dataLogDir: Highly recommended. Indicates a different directory to use for the transaction logs.
            EOF

            # Create an initialization marker file
            # This file indicates that an empty data directory is expected.
            # When present, an empty database is created and the marker file deleted.
            # When not present, an empty data directory will mean this peer will not have voting rights and it will not populate the data directory until it communicates with an active leader.
            # Intended use is to only create this file when bringing up a new ensemble.
            touch "$ZK_DATA_DIR"/initialize

            touch /opt/userdata-complete && chmod 644 /opt/userdata-complete
            echo "UserData has finished executing"

  ZkNodeSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for ZooKeeper instances
      VpcId: !Ref VpcId
      SecurityGroupEgress:
        - CidrIp: !Ref VpcCidr
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          Description: Allow TCP traffic out to VPC CIDR
        - DestinationPrefixListId: !Ref S3PrefixListId
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          Description: Allow TCP traffic out to S3 Gateway Endpoint

  ZkNodeSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref ZkNodeSecurityGroup
      Description: Allows all inbound traffic within VPC
      IpProtocol: "-1"
      # SourceSecurityGroupId: !Ref ZkNodeSecurityGroup
      CidrIp: !Ref VpcCidr

  ZkNodeSecurityGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref ZkNodeSecurityGroup
      Description: Allows all outbound traffic within VPC
      IpProtocol: "-1"
      # DestinationSecurityGroupId: !Ref ZkNodeSecurityGroup
      CidrIp: !Ref VpcCidr

  ZkNodeInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub ${IamPrefix}-ZooKeeper-Node-Instance-Profile-${ResourceSuffix}
      Roles: [!Ref ZkNodeRole]

  ZkNodeRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28 # Resource found with an explicit name, this disallows updates that require replacement of this resource
            reason: An explicit name is required
    Properties:
      RoleName: !Sub ${IamPrefix}-ZooKeeper-Node-${ResourceSuffix}
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      Description: Role to be assumed by ZooKeeper instances
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: KMS_Policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: kms:Decrypt
                Resource: !GetAtt KmsKey.Arn

  ZkClusterInfoParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub /zookeeper/cluster-${ResourceSuffix}
      Description: !Sub ZooKeeper nodes in ${ZkAutoScalingGroup}
      Type: String
      Value: "{}"

  ZkInstanceEventsRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub zookeeper-instance-events-rule-${ResourceSuffix}
      Description: !Sub Captures events when ZooKeeper instances in ${ZkAutoScalingGroup} launch or terminate
      State: ENABLED
      EventPattern:
        source:
          - aws.autoscaling
        detail-type:
          - EC2 Instance Launch Successful
          - EC2 Instance Terminate Successful
        detail:
          AutoScalingGroupName:
            - !Ref ZkAutoScalingGroup
      Targets:
        - Arn: !GetAtt ZkInstanceEventsProcessorFunction.Arn
          Id: !Ref ZkInstanceEventsProcessorFunction

  LambdaPermissionForZkInstanceEventsRule:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ZkInstanceEventsProcessorFunction
      Principal: events.amazonaws.com
      Action: lambda:InvokeFunction
      SourceArn: !GetAtt ZkInstanceEventsRule.Arn

  ZkInstanceEventsProcessorFunctionConfig:
    Type: AWS::Lambda::EventInvokeConfig
    Properties:
      FunctionName: !Ref ZkInstanceEventsProcessorFunction
      MaximumRetryAttempts: 0
      Qualifier: $LATEST

  ZkInstanceEventsProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub zookeeper-instance-events-processor-${ResourceSuffix}
      Description: Do Not Modify or Delete!
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt ZkInstanceEventsProcessorFunctionRole.Arn
      LoggingConfig:
        LogGroup: !Ref ZkInstanceEventsProcessorFunctionLogGroup
      # DeadLetterConfig:
      #   TargetArn:
      MemorySize: 512
      # ReservedConcurrentExecutions set to 1 to allow function execution only one at a time, to avoid race condition
      # If necessary, use DDB to implement a better locking mechanism, with timestamp for lock expiration
      ReservedConcurrentExecutions: 1
      Timeout: 900
      Environment:
        Variables:
          ASG_NAME: !Ref ZkAutoScalingGroup
          ZK_CLUSTER_PARAM: !Ref ZkClusterInfoParameter
      Code:
        ZipFile: |
          import json
          import logging
          import os
          from time import sleep

          import boto3  # type: ignore
          from botocore.config import Config  # type: ignore

          ZK_CLUSTER_PARAM = os.environ["ZK_CLUSTER_PARAM"]
          ASG_NAME = os.environ["ASG_NAME"]

          # Two possible event types
          LAUNCH_EVENT = "EC2 Instance Launch Successful"
          TERMINATION_EVENT = "EC2 Instance Terminate Successful"

          config = Config(retries={"max_attempts": 5, "mode": "standard"})
          SSM = boto3.client("ssm", config=config)
          EC2 = boto3.client("ec2", config=config)
          ASG = boto3.client("autoscaling", config=config)

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)


          def lambda_handler(event, context):
              logger.info(f"Event: {json.dumps(event, default=str)}")

              event_instance_id = event["detail"]["EC2InstanceId"]
              instance_added = event["detail-type"] == LAUNCH_EVENT
              instance_ids = get_instances_in_service(event_instance_id, instance_added)
              zk_cluster: dict[str, dict] = json.loads(get_param_value(ZK_CLUSTER_PARAM))
              id_to_dns_mapping = get_instance_id_to_dns_mapping(instance_ids)
              remove_instances_not_in_service(zk_cluster, instance_ids)
              add_instances_in_service(zk_cluster, instance_ids, id_to_dns_mapping)
              sorted_zk_cluster = dict(sorted(zk_cluster.items(), key=lambda n: n[1]["myid"]))
              update_param_value(ZK_CLUSTER_PARAM, json.dumps(sorted_zk_cluster))
              if sorted_zk_cluster:
                  wait_for_ssm_managed(sorted_zk_cluster)
                  send_command_to_cluster(sorted_zk_cluster)
              logger.info("Completed!")


          def get_instances_in_service(instance_id: str, instance_added: bool) -> list[str]:
              # https://docs.aws.amazon.com/autoscaling/ec2/userguide/ec2-auto-scaling-lifecycle.html

              logger.info(f"Getting instance IDs of all instances in service")

              if instance_added:
                  wait_for_in_service(instance_id)

              paginator = ASG.get_paginator("describe_auto_scaling_groups")
              instances_in_service = [
                  instance["InstanceId"]
                  for page in paginator.paginate(AutoScalingGroupNames=[ASG_NAME])
                  for asg in page["AutoScalingGroups"]
                  for instance in asg["Instances"]
                  if instance["LifecycleState"] == "InService"
              ]

              if not instance_added and instance_id in instances_in_service:
                  instances_in_service.remove(instance_id)

              logger.info(f"Instances in service: {instances_in_service}")
              return instances_in_service


          def wait_for_in_service(instance_id: str) -> None:
              """
              Waits for `instance_id` to be in service for up to ~5 minutes,
              checking for the state every 15 seconds
              """
              max_retries = 20
              paginator = ASG.get_paginator("describe_auto_scaling_instances")
              for i in range(max_retries):
                  logger.info(f"Attempt {i + 1} of {max_retries}: Checking if {instance_id} is in service")
                  in_service = any(instance["LifecycleState"] == "InService"
                                  for page in paginator.paginate(InstanceIds=[instance_id])
                                  for instance in page["AutoScalingInstances"])
                  if in_service:
                      logger.info(f"{instance_id} is in service")
                      return
                  if i < max_retries - 1:
                      logger.info(f"{instance_id} not in service yet; trying again in 15 seconds")
                      sleep(15)

              raise InstanceNotInServiceError(f"{instance_id} not in service after {max_retries} attempts")


          def get_instance_id_to_dns_mapping(instance_ids: list[str]) -> dict[str, str]:
              """
              Returns a dict with Instance ID as key and Private DNS Name as value for each instance
              """
              if not instance_ids:
                  return {}

              paginator = EC2.get_paginator("describe_instances")
              return {
                  instance["InstanceId"]: instance["PrivateDnsName"]
                  for page in paginator.paginate(InstanceIds=instance_ids)
                  for reservation in page["Reservations"]
                  for instance in reservation["Instances"]
              }


          def remove_instances_not_in_service(zk_cluster: dict[str, dict], instance_ids: list[str]):
              # Remove instances that are not in service
              for node_instance_id in list(zk_cluster):
                  if node_instance_id not in instance_ids:
                      del zk_cluster[node_instance_id]


          def add_instances_in_service(zk_cluster: dict[str, dict], instance_ids: list[str], id_to_dns_mapping: dict[str, str]):
              # Get existing myid values
              existing_myids = {node["myid"] for node in zk_cluster.values()}

              next_myid = 1
              # Add instances that are in service
              for instance_id in instance_ids:
                  if instance_id not in zk_cluster:
                      # Find the lowest available myid
                      while next_myid in existing_myids:
                          if next_myid > 20: # 20 was chosen arbitrarily, to prevent infinite loop
                              raise ValueError(f"{next_myid} went beyond the maximum allowed")
                          next_myid += 1
                      existing_myids.add(next_myid)  # Reserve this myid
                      zk_cluster[instance_id] = {"myid": next_myid, "dns": id_to_dns_mapping[instance_id]}
                      next_myid += 1


          def get_param_value(param_name: str, with_decryption=False) -> str:
              logger.info(f"Getting the value for {param_name} parameter")
              value = SSM.get_parameter(Name=param_name, WithDecryption=with_decryption)[
                  "Parameter"
              ]["Value"]
              logger.info(f"Param value: {value}")
              return value


          def update_param_value(param_name: str, param_value: str) -> None:
              logger.info(f"Updating the value for {param_name} parameter")
              SSM.put_parameter(Name=param_name, Value=param_value, Overwrite=True)
              logger.info(f"Param value updated to {param_value}")


          def wait_for_ssm_managed(zk_cluster: dict[str, dict]) -> None:
              max_retries = 20
              instance_ids = list(zk_cluster)
              paginator = SSM.get_paginator("describe_instance_information")
              for i in range(max_retries):
                  logger.info(f"Attempt {i + 1} of {max_retries}: Checking if {instance_ids} are managed nodes")
                  managed_instance_ids = [
                      instance["InstanceId"]
                      for page in paginator.paginate(Filters=[{"Key": "InstanceIds", "Values": instance_ids}])
                      for instance in page["InstanceInformationList"]
                  ]
                  non_managed_nodes = list(set(instance_ids) - set(managed_instance_ids))
                  if not non_managed_nodes:
                      logger.info(f"{instance_ids} are all managed nodes")
                      return
                  if i < max_retries - 1:
                      logger.info(f"{non_managed_nodes} are not managed nodes yet; trying again in 15 seconds")
                      sleep(15)

              raise InstanceNotManagedError(f"{non_managed_nodes} did not become managed nodes after {max_retries} attempts")


          def send_command_to_cluster(zk_cluster: dict[str, dict]) -> None:
              instance_command_ids = {instance_id: "" for instance_id in zk_cluster}
              max_retries = 5
              for i in range(max_retries):
                  remaining_instances = list(instance_command_ids)
                  if not remaining_instances:
                      return
                  for instance_id in remaining_instances:
                      commands = construct_commands(instance_id, zk_cluster)
                      instance_command_ids[instance_id] = send_command(instance_id, commands)
                  logger.info("Waiting 10 seconds before checking the command execution status") # execution itself takes 1-2 seconds on average
                  sleep(10)
                  for instance_id, command_id in list(instance_command_ids.items()):
                      logger.info(f"Attempt {i + 1} of {max_retries}: Checking if command ({command_id}) was successful on {instance_id}")
                      command_status = get_command_status(instance_id, command_id)
                      if command_status == "Success":
                          logger.info(f"Command was successful on {instance_id}")
                          del instance_command_ids[instance_id]
                      elif command_status in ("Pending", "InProgress", "Delayed"):
                          if i < max_retries - 1:
                              logger.info(f"Command status on {instance_id}: {command_status}; cancelling and trying again in 15 seconds")
                          else:
                              logger.info(f"Command status on {instance_id}: {command_status}; cancelling")
                          cancel_command(instance_id, command_id)
                      else: # 'Cancelled'|'TimedOut'|'Failed'|'Cancelling'
                          raise CommandUnsuccessful(f"Command status on {instance_id}: {command_status}")

              raise CommandUnsuccessful(f"Command status was not Success on {instance_command_ids.keys()} after {max_retries} attempts")


          def construct_commands(instance_id: str, zk_cluster: dict) -> list[str]:
              # https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_zkMulitServerSetup

              # Note: The list of servers that make up ZooKeeper servers that is used by the clients must match
              # the list of ZooKeeper servers that each ZooKeeper server has

              num_of_instances_in_service = len(zk_cluster)

              zk_servers = "\n".join(f'server.{v["myid"]}={v["dns"]}:2888:3888;2181' for v in zk_cluster.values())
              zk_server_id = zk_cluster[instance_id]["myid"]

              commands = f"""
          set -ex

          for i in {{1..30}}; do
              echo "Attempt "$i" of 30 to check if UserData has been run to completion"
              if [ -f "/opt/userdata-complete" ]; then
                  echo "UserData has been run to completion"
                  break
              else
                  if [ $i = 30 ]; then
                      echo "Could not verify UserData has been run to completion"
                      exit 1
                  fi
                  echo "UserData may still be running; retrying in 10 seconds"
                  sleep 10
              fi
          done

          source /etc/environment

          # The following configuration keywords are considered part of the dynamic configuration: server, group and weight.

          zk_dynamic_config="$ZK_HOME"/conf/zoo.cfg.dynamic
          touch "$zk_dynamic_config"
          # Delete existing lines
          sed -i '\|server.[0-9]\+=|d' $zk_dynamic_config
          # Add servers at the end of the file
          cat >> "$zk_dynamic_config" << EOF
          {zk_servers}
          EOF

          echo {zk_server_id} > "$ZK_DATA_DIR"/myid

          if [ {num_of_instances_in_service} -ge 3 ] && ! "$ZK_HOME"/bin/zkServer.sh status; then
              "$ZK_HOME"/bin/zkServer.sh start
              # Alternative (run inside $ZK_HOME):
              # java -cp zookeeper.jar:lib/*:conf org.apache.zookeeper.server.quorum.QuorumPeerMain conf/zoo.cfg
          fi
          """
              return [line for line in commands.split("\n")]


          def send_command(instance_id: str, commands: list[str]) -> str:
              """
              Sends `commands` to the specified instance and returns the CommandId
              """
              logger.info(f"Sending commands to {instance_id}")
              return SSM.send_command(
                  InstanceIds=[instance_id],
                  DocumentName="AWS-RunShellScript",
                  Parameters={
                      "commands": commands
                  },
              )["Command"]["CommandId"]


          def get_command_status(instance_id: str, command_id: str) -> str:
              """
              Returns command status if available, otherwise "Unknown"
              """
              response = SSM.get_command_invocation(
                  InstanceId=instance_id,
                  CommandId=command_id,
              )
              status = response["Status"]
              if response["ResponseCode"] == -1:
                  logger.info("ResponseCode was -1")
                  status = "Pending"
              return status


          def cancel_command(instance_id: str, command_id: str) -> None:
              SSM.cancel_command(InstanceIds=[instance_id], CommandId=command_id)


          class InstanceNotInServiceError(Exception):
              pass


          class InstanceNotManagedError(Exception):
              pass


          class CommandUnsuccessful(Exception):
              pass

  ZkInstanceEventsProcessorFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${IamPrefix}-zk-instances-events-processor-role-${ResourceSuffix}
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
      Policies:
        - PolicyName: CloudWatchPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !GetAtt ZkInstanceEventsProcessorFunctionLogGroup.Arn
        - PolicyName: SSMPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:PutParameter
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter${ZkClusterInfoParameter}
              - Effect: Allow
                Action:
                  - ssm:DescribeInstanceInformation
                  - ssm:GetCommandInvocation
                  - ssm:CancelCommand
                Resource: "*"
                Condition:
                  StringEquals:
                    aws:ResourceAccount: !Ref AWS::AccountId
                    aws:RequestedRegion: !Ref AWS::Region
              - Effect: Allow
                Action: ssm:SendCommand
                Resource:
                  - !Sub arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/*
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}::document/AWS-RunShellScript
        - PolicyName: EC2Policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: ec2:DescribeInstances
                Resource: "*"
                Condition:
                  StringEquals:
                    aws:ResourceAccount: !Ref AWS::AccountId
                    ec2:Region: !Ref AWS::Region
        - PolicyName: AutoScalingGroupPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - autoscaling:DescribeAutoScalingGroups
                  - autoscaling:DescribeAutoScalingInstances
                Resource: "*"
                Condition:
                  StringEquals:
                    aws:ResourceAccount: !Ref AWS::AccountId
                    aws:RequestedRegion: !Ref AWS::Region

  ZkInstanceEventsProcessorFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub zookeeper-instance-events-processor-${ResourceSuffix}
      RetentionInDays: 90
      KmsKeyId: !GetAtt KmsKey.Arn

  # ZkRequiredFilesBucket:
  #   Type: AWS::S3::Bucket
  #   DeletionPolicy: Delete
  #   UpdateReplacePolicy: Delete
  #   Properties:
  #     OwnershipControls:
  #       Rules:
  #         - ObjectOwnership: BucketOwnerEnforced
  #     # LoggingConfiguration:
  #     #   DestinationBucketName: BucketName
  #     BucketEncryption:
  #       ServerSideEncryptionConfiguration:
  #         - ServerSideEncryptionByDefault:
  #             KMSMasterKeyID: !GetAtt KmsKey.Arn
  #             SSEAlgorithm: aws:kms # Uses aws/s3
  #           BucketKeyEnabled: true
  #     PublicAccessBlockConfiguration:
  #       BlockPublicAcls: true
  #       IgnorePublicAcls: true
  #       BlockPublicPolicy: true
  #       RestrictPublicBuckets: true
  #     VersioningConfiguration:
  #       Status: Enabled
  #     ObjectLockEnabled: true

  # ZkRequiredFilesBucketPolicy:
  #   Type: AWS::S3::BucketPolicy
  #   Properties:
  #     Bucket: !Ref ZkRequiredFilesBucket
  #     PolicyDocument:
  #       Statement:
  #         - Effect: Deny
  #           Principal: "*"
  #           Action: s3:*
  #           Resource:
  #             - !Sub ${ZkRequiredFilesBucket.Arn}/*
  #             - !Sub ${ZkRequiredFilesBucket.Arn}
  #           Condition:
  #             Bool:
  #               aws:SecureTransport: false
  #         - Sid: AllowTls12Only
  #           Effect: Deny
  #           Principal: "*"
  #           Action: s3:*
  #           Resource:
  #             - !Sub ${ZkRequiredFilesBucket.Arn}
  #             - !Sub ${ZkRequiredFilesBucket.Arn}/*
  #           Condition:
  #             NumericLessThan:
  #               s3:TlsVersion: 1.2

  KmsKey:
    Type: AWS::KMS::Key
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      Description: KMS key for root CA stack
      Enabled: true
      EnableKeyRotation: true
      PendingWindowInDays: 30
      KeyPolicy:
        Version: 2012-10-17
        Statement:
          - Sid: Allow administration of the key via IAM policies
            Effect: Allow
            Principal:
              AWS: !Ref AWS::AccountId
            NotAction:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:CreateGrant
            Resource: "*"
          - Sid: Allow use of the key only for AWS via IAM policies
            Effect: Allow
            Principal:
              AWS: !Ref AWS::AccountId
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:CreateGrant
            Resource: "*"
            Condition:
              StringEquals:
                kms:CallerAccount: !Ref AWS::AccountId
          - Sid: Allow logs service principal to use the key
            Effect: Allow
            Principal:
              Service: !Sub logs.${AWS::Region}.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: "*"
            Condition:
              ArnLike:
                kms:EncryptionContext:aws:logs:arn:
                  - !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:*
          - Sid: Allow imagebuilder service-linked role to use the key
            Effect: Allow
            Principal:
              AWS: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/imagebuilder.amazonaws.com/AWSServiceRoleForImageBuilder
            Action:
              - kms:GenerateDataKey*
              - kms:Decrypt
            Resource: "*"
            Condition:
              StringLike:
                kms:EncryptionContext:aws:imagebuilder:arn: !Sub arn:${AWS::Partition}:imagebuilder:*:${AWS::AccountId}:workflow/*

Outputs:
  ZkClusterInfoParameterName:
    Description: Name of SSM Parameter that contains ZooKeeper cluster information
    Value: !Ref ZkClusterInfoParameter
