#!/bin/bash
# post-deploy-keycloak.sh - Updates RDS endpoint and ExternalSecret after deployment

# Get script directory and set relative paths
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
BASE_DIR="$(dirname "$SCRIPT_DIR")"

# Get configuration from configuration.yaml
CONFIG_FILE="$BASE_DIR/../../../env/${ENVIRONMENT:-govcloud}/configuration.yaml"
CONFIG_REGION=$(grep "region:" "$CONFIG_FILE" | awk '{print $NF}' | tr -d '"')
CONFIG_CLUSTER_NAME=$(grep -A 1 "clusters:" "$CONFIG_FILE" | grep "name:" | head -1 | awk '{print $NF}' | tr -d '"')

# Set cluster name and region with fallbacks
CLUSTER_NAME=${1:-${CONFIG_CLUSTER_NAME:-"SharedServices"}}
REGION=${2:-${CONFIG_REGION:-"us-gov-west-1"}}

# Get actual RDS endpoint
RDS_ENDPOINT=$(aws rds describe-db-clusters --db-cluster-identifier keycloak-aurora-postgres --query 'DBClusters[0].Endpoint' --output text --region $REGION 2>/dev/null)

if [ -z "$RDS_ENDPOINT" ] || [ "$RDS_ENDPOINT" = "None" ]; then
  echo "Error: RDS cluster not found. Make sure it's deployed and available."
  exit 1
fi

echo "Found RDS endpoint: $RDS_ENDPOINT"

# Get the master user secret ARN from the RDS cluster
MASTER_USER_SECRET_ARN=$(aws rds describe-db-clusters --db-cluster-identifier keycloak-aurora-postgres --query 'DBClusters[0].MasterUserSecret.SecretArn' --output text --region $REGION 2>/dev/null)

if [ -n "$MASTER_USER_SECRET_ARN" ] && [ "$MASTER_USER_SECRET_ARN" != "None" ]; then
  # Extract secret name from ARN (format: arn:aws:secretsmanager:region:account:secret:name-suffix)
  RDS_SECRET_NAME=$(echo "$MASTER_USER_SECRET_ARN" | sed 's/.*secret://' | sed 's/-[^-]*$//')
  echo "Found RDS secret: $RDS_SECRET_NAME"
  
  # Update SecretProviderClass with actual secret name (handles any existing value)
  sed -i.bak "s|objectName: \"[^\"]*\"|objectName: \"$RDS_SECRET_NAME\"|g" "$BASE_DIR/secrets/secret-provider.yaml"
  echo "Updated SecretProviderClass with actual secret name"
else
  echo "Warning: Could not find master user secret for keycloak-aurora-postgres"
fi

# Create service with real endpoint
cat > "$BASE_DIR/rds/keycloak-db-service.yaml" << EOF
# This file is generated by the post-deploy script with the actual RDS endpoint
apiVersion: v1
kind: Service
metadata:
  name: keycloak-aurora-postgres
  namespace: keycloak
spec:
  type: ExternalName
  externalName: "$RDS_ENDPOINT"
  ports:
  - port: 5432
    targetPort: 5432
EOF



# Get the role ARN from the deployed stack using dynamic cluster name
ROLE_ARN=$(aws iam list-roles --query "Roles[?contains(RoleName,\`${CLUSTER_NAME}-csi-secrets-role\`)].Arn" --output text --region $REGION)

if [ -n "$ROLE_ARN" ]; then
  echo "Found Secrets CSI Role: $ROLE_ARN"
  
  # Update service account with actual role ARN (handles any existing value)
  sed -i.bak "s|eks.amazonaws.com/role-arn: \"[^\"]*\"|eks.amazonaws.com/role-arn: \"$ROLE_ARN\"|g" "$BASE_DIR/secrets/service-account.yaml"
  echo "Updated service account with role ARN"
else
  echo "Warning: Could not find role containing ${CLUSTER_NAME}-csi-secrets-role"
fi

echo "Post-deploy: Updated RDS endpoint and service account files"
echo "Next: Run 'kubectl apply -k k8s/overlay/dev/post' to deploy applications"