AWSTemplateFormatVersion: 2010-09-09

Description: Nice DCV Infrastructure with DCV-Session Manager and DCV-Connection Gateway and DCV Server

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: General
        Parameters:
          - IamPrefix
          - PermissionsBoundaryPolicyArn

      - Label:
          default: VPC Configuration
        Parameters:
          - VpcCidr
          - PublicSubnet1Cidr
          - PublicSubnet2Cidr
          - PrivateSubnet1Cidr
          - PrivateSubnet2Cidr
          - AvailabilityZone1
          - AvailabilityZone2
      - Label:
          default: DCV Configuration
        Parameters:
          - KeyName
          - InstanceType
          - ImageId
          
      - Label:
          default: EBS Volume COnfiguration
        Parameters:
          - EbsVolumeSize
      - Label:
          default: Auto Scaling Group Configuration
        Parameters:
          - AutoScalingMinSize
          - AutoScalingMaxSize
          - AutoScalingDesiredCapacity
          - CpuUtilizationTarget
      
    ParameterLabels:
      IamPrefix:
        default: IAM Prefix
      PermissionsBoundaryPolicyArn:
        default: Permissions Boundary Policy ARN
      VpcCidr:
        default: VPC CIDR
      PrivateSubnet1Cidr:
        default: Private Subnet 1 CIDR
      PrivateSubnet2Cidr:
        default: Private Subnet 2 CIDR
      PublicSubnet1Cidr:
        default: Public Subnet 1 CIDR
      PublicSubnet2Cidr:
        default: Public Subnet 2 CIDR
      AvailabilityZone1:
        default: Availability Zone 1
      AvailabilityZone2:
        default: Availability Zone 2
      KeyName:
        default: Key Pair Name
      ImageId:
        default: DCV AMI ID
      InstanceType:
        default: DCV Instance Type
      EbsVolumeSize:
        default: EBS Volume Size
      AutoScalingMinSize:
        default: Auto Scaling Group Min Size
      AutoScalingMaxSize:
        default: Auto Scaling Group Max Size
      AutoScalingDesiredCapacity:
        default: Auto Scaling Group Desired Capacity
      CpuUtilizationTarget:
        default: CPU Utilization Target
      WindowsServerAmiId:
        default: Windows Server AMI ID
Parameters:
  IamPrefix:
    Type: String
    Description: Required prefix for IAM resources
    Default: AFC2S
    AllowedValues: [AFC2S]
    ConstraintDescription: Must be "AFC2S"

  PermissionsBoundaryPolicyArn:
    Type: String
    Description: ARN of the policy that is used to set the permissions boundary for IAM resources
    AllowedPattern: ^arn:(aws|aws):iam::(\d{12}|aws):policy/.*
    ConstraintDescription: Must be a valid IAM policy ARN
    Default: arn:aws:iam::aws:policy/AdministratorAccess

  VpcCidr:
    Type: String
    Default: 10.0.0.0/16
    Description: CIDR block for the VPC

  PublicSubnet1Cidr:
    Type: String
    Default: 10.0.0.0/24
    Description: CIDR block for the public subnet in AZ1

  PublicSubnet2Cidr:
    Type: String
    Default: 10.0.1.0/24
    Description: CIDR block for the public subnet in AZ2

  PrivateSubnet1Cidr:
    Type: String
    Default: 10.0.2.0/24
    Description: CIDR block for the private subnet in AZ1

  PrivateSubnet2Cidr:
    Type: String
    Default: 10.0.3.0/24
    Description: CIDR block for the private subnet in AZ2

  AvailabilityZone1:
    Type: AWS::EC2::AvailabilityZone::Name
    Default: us-east-1a
    Description: Availability Zone 1

  AvailabilityZone2:
    Type: AWS::EC2::AvailabilityZone::Name
    Default: us-east-1b
    Description: Availability Zone 2

  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Name of an existing EC2 KeyPair

  InstanceType:
    Type: String
    Default: m6g.large
    Description: Instance type for the DCV Session Manager, DCV Connection Gateway and DCV Server

  ImageId:
    Type: AWS::EC2::Image::Id
    Default: ami-02efd0d9e75e2bf32
    Description: AMI ID for for the DCV Session Manager, DCV Connection Gateway and DCV Server

  EbsVolumeSize:
    Type: Number
    Default: 25
    Description: Size of the EBS volume in GB

  AutoScalingMinSize:
    Type: Number
    Default: 1
    Description: Minimum size for Auto Scaling Group

  AutoScalingMaxSize:
    Type: Number
    Default: 5
    Description: Maximum size for Auto Scaling Group

  AutoScalingDesiredCapacity:
    Type: Number
    Default: 1
    Description: Desired capacity for Auto Scaling Group

  CpuUtilizationTarget:
    Type: Number
    Default: 75
    Description: Target CPU Utilization percentage for Auto Scaling
  WindowsServerAmiId:
    Type: AWS::EC2::Image::Id
    Default: ami-02e3d076cbd5c28fa
    Description: AMI ID for the Windows DCV Fleet Server
Resources:

  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref AvailabilityZone1
      CidrBlock: !Ref PublicSubnet1Cidr
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PublicSubnet1

  PublicSubnet1RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PublicSubnet1/RTB

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicSubnet1RouteTable
      SubnetId: !Ref PublicSubnet1

  PublicSubnet1RouteTableDefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicSubnet1RouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref IGW
    DependsOn:
      - IGWGatewayAttachment

  PublicSubnet1EIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PublicSubnet1/EIP

  PublicSubnet1NatGateway:
    Type: AWS::EC2::NatGateway
    Properties:
      SubnetId: !Ref PublicSubnet1
      AllocationId: !GetAtt PublicSubnet1EIP.AllocationId
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PublicSubnet1/NATGateway

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref AvailabilityZone2
      CidrBlock: !Ref PublicSubnet2Cidr
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PublicSubnet2

  PublicSubnet2RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PublicSubnet2/RTB

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicSubnet2RouteTable
      SubnetId: !Ref PublicSubnet2

  PublicSubnet2DefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicSubnet2RouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref IGW
    DependsOn:
      - IGWGatewayAttachment

  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref AvailabilityZone1
      CidrBlock: !Ref PrivateSubnet1Cidr
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PrivateSubnet1

  PrivateSubnet1RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PrivateSubnet1/RTB

  PrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateSubnet1RouteTable
      SubnetId: !Ref PrivateSubnet1

  PrivateSubnet1DefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateSubnet1RouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref PublicSubnet1NatGateway

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Ref AvailabilityZone2
      CidrBlock: !Ref PrivateSubnet2Cidr
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PrivateSubnet2

  PrivateSubnet2RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC/PrivateSubnet2/RTB

  PrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateSubnet2RouteTable
      SubnetId: !Ref PrivateSubnet2

  PrivateSubnet2DefaultRoute:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateSubnet2RouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref PublicSubnet1NatGateway

  IGW:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/VPC

  IGWGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref IGW

  VpcEndpointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for VPC Endpoints
      SecurityGroupEgress:
        - CidrIp: 127.0.0.1/32
          Description: No outbound traffic allowed
          IpProtocol: "-1"
      SecurityGroupIngress:
        - CidrIp: !Ref VpcCidr
          Description: Allows inbound HTTPS traffic
          FromPort: 443
          IpProtocol: tcp
          ToPort: 443
      VpcId: !Ref VPC

  # VPC Endpoints
  SsmVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !GetAtt VpcEndpointSecurityGroup.GroupId
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ssm
      SubnetIds: 
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      VpcEndpointType: Interface
      VpcId: !Ref VPC

  SsmMessagesVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !GetAtt VpcEndpointSecurityGroup.GroupId
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ssmmessages
      SubnetIds: 
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      VpcEndpointType: Interface
      VpcId: !Ref VPC

  Ec2MessagesVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PrivateDnsEnabled: true
      SecurityGroupIds:
        - !GetAtt VpcEndpointSecurityGroup.GroupId
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ec2messages
      SubnetIds: 
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      VpcEndpointType: Interface
      VpcId: !Ref VPC

  # Security Groups
  SMSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Default ports for DCV Session, Gateway, and Broker
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DCV-Session-Manager-SG

  SMSecurityGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !GetAtt SMSecurityGroup.GroupId
      IpProtocol: '-1'
      CidrIp: 0.0.0.0/0
      Description: Allow all outbound traffic by default

  SMSecurityGroupIngressBrokerTCP8443:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt SMSecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 8443
      ToPort: 8443
      CidrIp: 0.0.0.0/0
      Description: allow CLI to Broker communication

  SMSecurityGroupIngressBrokerTCP8447:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt SMSecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 8447
      ToPort: 8447
      CidrIp: 0.0.0.0/0
      Description: allow Gateway to Broker resolver communication

  SMSecurityGroupIngressBrokerTCP8445:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt SMSecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 8445
      ToPort: 8445
      CidrIp: 0.0.0.0/0
      Description: allow Agent to Broker communication

  SMSecurityGroupIngressBrokerTCP443:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt SMSecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: !Ref VpcCidr
      Description: allow SSM to Broker communication

  SMSecurityGroupEgressBroker:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt SMSecurityGroup.GroupId
      IpProtocol: '-1'
      SourceSecurityGroupId: !GetAtt SMSecurityGroup.GroupId
      Description: allow Broker to Broker communication

  ConnectionGatewaySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: SG default ports for DCV Connection Gateway
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DCV-Connection-Gateway-SG

  ConnectionGatewaySecurityGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
      IpProtocol: '-1'
      CidrIp: 0.0.0.0/0
      Description: Allow all outbound traffic by default

  ConnectionGatewaySecurityGroupIngressTCP:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 8443
      ToPort: 8443
      CidrIp: 0.0.0.0/0
      Description: allow TCP DCV access from public internet
  
  ConnectionGatewaySecurityGroupIngressTCPfromNLB:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 8989
      ToPort: 8989
      CidrIp: 0.0.0.0/0
      Description: allow health check for NLB targets

  ConnectionGatewaySecurityGroupIngressUDP:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
      IpProtocol: udp
      FromPort: 8443
      ToPort: 8443
      CidrIp: 0.0.0.0/0
      Description: allow UDP DCV access from public internet
  
  ConnectionGatewaySecurityGroupIngressTCP443:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: !Ref VpcCidr
      Description: allow SSM to Connection Gateway communication

  # IAM Roles and Policies
  DCVFleetRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${IamPrefix}-${AWS::StackName}-dcv-fleet-role
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: DCV-Fleet-Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: s3:GetObject
                Resource: !Sub arn:${AWS::Partition}:s3:::dcv-license.${AWS::Region}/*
              - Effect: Allow
                Action: S3:GetObject
                Resource: '*'
              - Effect: Allow
                Action: 
                  - ssm:GetParameter
                  - ssm:DescribeParameters
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/dcv-*

  DCVSessionMgrRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${IamPrefix}-${AWS::StackName}-dcv-session-mgr-role
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
        - !Sub arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSXRayDaemonWriteAccess
      Policies:
        - PolicyName: DCV-SessionMgr-Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: ssm:DescribeParameters
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:PutParameter
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/dcv-*

  DCVConnectionGwyRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${IamPrefix}-${AWS::StackName}-DCV-Connection-Gateway-Role
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: DCV-ConnectionGwy-Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: ssm:DescribeParameters
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:PutParameter
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/dcv-*

  # Instance Profiles
  DCVFleetServerInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref DCVFleetRole

  SessionMgrInstanceInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref DCVSessionMgrRole

  ConnectionGwyLaunchTemplateProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref DCVConnectionGwyRole

  # EC2 Instances and Launch Templates
  SessionMgrInstance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: !Ref AvailabilityZone1
      IamInstanceProfile: !Ref SessionMgrInstanceInstanceProfile
      ImageId: !Ref ImageId
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyName
      SecurityGroupIds:
        - !GetAtt SMSecurityGroup.GroupId
      SubnetId: !Ref PrivateSubnet1
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DcvInfraStack/SessionMgrBroker
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: !Ref EbsVolumeSize
            VolumeType: gp3
            Encrypted: true
            # TODO Use CMK
            KmsKeyId: !Sub arn:${AWS::Partition}:kms:${AWS::Region}:${AWS::AccountId}:alias/aws/ebs
      UserData: 
        Fn::Base64: |-
          #!/bin/bash
          set -eE

          # Set up logging
          LOG_PATH="/var/log/dcv-session-mgr-broker.log"
          LOG_DIR=$(dirname "$LOG_PATH")
          echo $(date -u) "*****START USER DATA SCRIPT*****" | tee -a "$LOG_PATH"

          # Retrieve System Info
          read -r system version <<<$(echo $(cat /etc/os-release | grep "^ID=\|^VERSION_ID=" | sort | cut -d"=" -f2 | tr -d "\"" | tr '[:upper:]' '[:lower:]'))
          major_version="${version%.*}"
          arch="$(arch)"

          # Update system packages
          echo $(date -u) "Updating system packages..." | tee -a "$LOG_PATH"
          dnf update -y

          # Install required packages
          echo $(date -u) "Installing required packages..." | tee -a "$LOG_PATH"
          dnf install -y unzip curl wget

          # Install AWS CLI
          echo $(date -u) "Installing AWS CLI..." | tee -a "$LOG_PATH"

          # Update PATH to include AWS CLI location
          export PATH=/usr/local/bin:$PATH

          if ! command -v aws &> /dev/null; then
              echo $(date -u) "AWS CLI not found. Installing..." | tee -a "$LOG_PATH"
              
              # Create temporary directory for AWS CLI installation
              AWS_CLI_TMP="$(mktemp -d /tmp/aws-cli-XXXXXX)"
              trap 'rm -rf -- "$AWS_CLI_TMP"' ERR
              
              if [ "$arch" = "x86_64" ]; then
                  curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "$AWS_CLI_TMP/awscliv2.zip"
              else
                  curl -s "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "$AWS_CLI_TMP/awscliv2.zip"
              fi
              
              unzip -q "$AWS_CLI_TMP/awscliv2.zip" -d "$AWS_CLI_TMP"
              "$AWS_CLI_TMP/aws/install" --update
              rm -rf "$AWS_CLI_TMP"
              
              # Create symlink if needed
              if [ -f "/usr/local/aws-cli/v2/current/bin/aws" ] && [ ! -f "/usr/local/bin/aws" ]; then
                  ln -s /usr/local/aws-cli/v2/current/bin/aws /usr/local/bin/aws
              fi
              
              echo $(date -u) "AWS CLI installation completed" | tee -a "$LOG_PATH"
          else
              echo $(date -u) "AWS CLI already installed" | tee -a "$LOG_PATH"
          fi

          # Verify AWS CLI
          if ! command -v aws &> /dev/null; then
              echo $(date -u) "Error: AWS CLI not accessible after installation" | tee -a "$LOG_PATH"
              exit 1
          fi

          AWS_VERSION=$(aws --version 2>&1)
          echo $(date -u) "AWS CLI verified: $AWS_VERSION" | tee -a "$LOG_PATH"

          # Install SSM Agent
          echo $(date -u) "Installing/Updating SSM Agent..." | tee -a "$LOG_PATH"
          case $system in
              amzn|centos|rhel )
                  if ! systemctl status amazon-ssm-agent &> /dev/null; then
                      if [ "$arch" = "x86_64" ]; then
                          yum install -y https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_amd64/amazon-ssm-agent.rpm
                      else
                          yum install -y https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_arm64/amazon-ssm-agent.rpm
                      fi
                  else
                      systemctl restart amazon-ssm-agent
                  fi
                  ;;
              ubuntu )
                  if ! systemctl status amazon-ssm-agent &> /dev/null; then
                      mkdir -p /tmp/ssm
                      if [ "$arch" = "x86_64" ]; then
                          wget https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/debian_amd64/amazon-ssm-agent.deb -O /tmp/ssm/amazon-ssm-agent.deb
                      else
                          wget https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/debian_arm64/amazon-ssm-agent.deb -O /tmp/ssm/amazon-ssm-agent.deb
                      fi
                      dpkg -i /tmp/ssm/amazon-ssm-agent.deb
                      rm -rf /tmp/ssm
                  else
                      systemctl restart amazon-ssm-agent
                  fi
                  ;;
          esac

          # Enable and start SSM Agent
          systemctl enable amazon-ssm-agent
          systemctl start amazon-ssm-agent
          echo $(date -u) "SSM Agent installation/update completed" | tee -a "$LOG_PATH"

          CLOUDFRONT_PREFIX="https://d1uj6qtbmh3dt5.cloudfront.net"
          TMP_DIR="$(mktemp -d /tmp/XXXXXX)"
          trap 'rm -rf -- "$TMP_DIR"' ERR

          case $system in
              amzn )
                  if [ "$major_version" = 2 ]; then
                      package_type="el7"
                      package_manager="yum"
                      package_extension="rpm"
                  fi
                  ;;
              centos|rhel )
                  if [[ "$major_version" =~ ^(7|8|9) ]]; then
                      package_type="el$major_version"
                      if [[ "$major_version" =~ ^(8|9) ]]; then
                      package_manager="dnf"
                      else
                      package_manager="yum"
                      fi
                      package_extension="rpm"
                  fi
                  ;;
              ubuntu )
                  if [ "$major_version" = 22 ] || [ "$major_version" = 20 ]; then
                      package_type="ubuntu$(echo $version | tr -d '.')"
                      package_manager="apt"
                      package_extension="deb"
                  fi
                  ;;
              * )
                  echo "Error: system '$system' is not supported"
                  exit 1
                  ;;
          esac


          if [ -z "$package_type" ]; then
              echo "Error: system '$system' with version '$version' is not supported for arch '$arch'"
              exit 1
          fi

          # Download Packages
          if [ "$package_manager" = apt ]; then
              curl -o "$TMP_DIR/NICE-GPG-KEY" "$CLOUDFRONT_PREFIX/NICE-GPG-KEY"
              gpg --import "$TMP_DIR/NICE-GPG-KEY"
              curl -o "$TMP_DIR/nice-dcv-session-manager-broker.$package_extension" "$CLOUDFRONT_PREFIX/nice-dcv-session-manager-broker_all.$package_type.$package_extension"
          else
              rpm --import "$CLOUDFRONT_PREFIX"/NICE-GPG-KEY
              curl -o "$TMP_DIR/nice-dcv-session-manager-broker.$package_extension" "$CLOUDFRONT_PREFIX/nice-dcv-session-manager-broker-$package_type.noarch.$package_extension"
          fi

          # Install Packages
          for package_pattern in "nice-dcv-session-manager-broker.$package_extension"; do
              package_full_path=$(find "$TMP_DIR" -name "$package_pattern")
              "$package_manager" install -y "$package_full_path"
          done

          # Enable and start DCV Session Manager service
          systemctl start dcv-session-manager-broker
          systemctl enable dcv-session-manager-broker
          # sudo cp /var/lib/dcvsmbroker/security/dcvsmbroker_ca.pem /root


          #################################################################

          echo $(date -u) "List Cert files: $(ls /var/lib/dcvsmbroker/security)" | tee -a "$LOG_PATH"

          # Add this right after the DCV service starts
          echo $(date -u) "Waiting for DCV broker CA certificate to be created..." | tee -a "$LOG_PATH"

          # Wait for the certificate file to exist (up to 60 seconds)
          count=0
          while [ ! -f "/var/lib/dcvsmbroker/security/dcvsmbroker_ca.pem" ] && [ $count -lt 60 ]; do
              echo $(date -u) "Waiting for CA certificate file ($count/60 seconds)..." | tee -a "$LOG_PATH"
              sleep 1
              count=$((count+1))
          done

          # Now check and try to copy
          if [ -f "/var/lib/dcvsmbroker/security/dcvsmbroker_ca.pem" ]; then
              echo $(date -u) "CA certificate found, copying to destination" | tee -a "$LOG_PATH"
              sudo cp /var/lib/dcvsmbroker/security/dcvsmbroker_ca.pem /root/dcvsmbroker_ca.pem
              echo $(date -u) "CA certificate copied successfully" | tee -a "$LOG_PATH"
          else
              echo $(date -u) "ERROR: CA certificate file not found after waiting 60 seconds" | tee -a "$LOG_PATH"
              ls -la /var/lib/dcvsmbroker/security/ >> "$LOG_PATH" 2>&1
          fi
          ################################################################################



          # Configure DCV Session Manager
          CONFIG_PATH="/etc/dcv-session-manager-broker/session-manager-broker.properties"
          ## Enable the gateway in config
          sed -i '/^enable-gateway/s/=.*$/= true/' "$CONFIG_PATH"
          ## Uncomment the broker connector host and port in config
          sed -i '/gateway-to-broker-connector-https-port/s/^#\s//g' "$CONFIG_PATH"
          sed -i '/gateway-to-broker-connector-bind-host/s/^#\s//g' "$CONFIG_PATH"
          ## (Optional) Enable the broker to persist on DynamoDB in config
          #sed -i '/^enable-persistence/s/=.*$/= true/' "$CONFIG_PATH"
          ### Uncomment database, region, Read Capacity Units(RCU), Write Capacity Units(WCU), and table name prefix in config
          #sed -i '/persistence-db/s/^#\s//g' "$CONFIG_PATH"
          #sed -i '/dynamodb-region/s/^#\s//g' "$CONFIG_PATH"
          #sed -i '/dynamodb-table-rcu/s/^#\s//g' "$CONFIG_PATH"
          #sed -i '/dynamodb-table-wcu/s/^#\s//g' "$CONFIG_PATH"
          #sed -i '/dynamodb-table-name-prefix/s/^#\s//g' "$CONFIG_PATH"
          #sed -i "/^dynamodb-region/s/=.*$/= $REGION/" "$CONFIG_PATH"

          # Restart the broker service
          systemctl restart dcv-session-manager-broker.service

          # Clean Up
          rm -rf "$TMP_DIR"

          # Get the private IP for connection gateway to use during configuration
          echo $(date -u) "Retrieving private broker DNS..." | tee -a "$LOG_PATH"
          TOKEN=`curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600"`
          MAC=`curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/network/interfaces/macs/`
          PRIVATE_DNS=`curl -H "X-aws-ec2-metadata-token: $TOKEN" "http://169.254.169.254/latest/meta-data/network/interfaces/macs/${MAC}local-hostname"`
          echo $(date -u) "Using private DNS $PRIVATE_DNS" | tee -a "$LOG_PATH"
          echo "PRIVATE_DNS=$PRIVATE_DNS" > /tmp/dcv-credentials

          # Get current region
          REGION=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)
          echo $(date -u) "Current Region: $REGION" | tee -a "$LOG_PATH"

          # Store the private private DNS name in SSM Parameter Store
          echo $(date -u) "Storing broker private DNS name in AWS SSM Parameter Store..." | tee -a "$LOG_PATH"
          aws ssm put-parameter --name dcv-broker-private-dns --value "$PRIVATE_DNS" --type String --overwrite --region "$REGION"

          # Store dcvsmbroker_ca.pem in SSM Parameter Store
          echo $(date -u) "Storing dcvsmbroker_ca.pem in AWS SSM Parameter Store..." | tee -a "$LOG_PATH"
          # Read the content of the CA certificate
          CA_CERT_CONTENT=$(sudo cat /var/lib/dcvsmbroker/security/dcvsmbroker_ca.pem)
          echo $(date -u) "CA Cert Content: ${CA_CERT_CONTENT}" | tee -a "$LOG_PATH"
          # Store the CA certificate content in SSM Parameter Store
          aws ssm put-parameter --name dcv-broker-ca-cert --value "$CA_CERT_CONTENT" --type SecureString --overwrite --region "$REGION"

          # Log if successful installation
          if [[ $? -eq 0 ]]; then
              echo $(date -u) "Stored private DNS name $PRIVATE_DNS in Parameter Store" | tee -a "$LOG_PATH"
              echo $(date -u) "Successfully stored dcvsmbroker_ca.pem in Parameter Store" | tee -a "$LOG_PATH"
          else
              echo $(date -u) "There was an error during DCV Session Manager installation" | tee -a "$LOG_PATH"
              echo $(date -u) "Failed to store dcvsmbroker_ca.pem in Parameter Store" | tee -a "$LOG_PATH"
          fi

          # Install wget and other dependencies
          echo "$(date -u) Installing required packages..." | tee -a "$LOG_PATH"
          if command -v apt-get &> /dev/null; then
              apt-get update
              apt-get install -y wget unzip
          elif command -v yum &> /dev/null; then
              yum install -y wget unzip
          elif command -v dnf &> /dev/null; then
              dnf install -y wget unzip
          else
              echo "$(date -u) No supported package manager found" | tee -a "$LOG_PATH"
              exit 1
          fi

          # Register API Client and save credentials
          API_CLIENT_OUTPUT=$(sudo -u root dcv-session-manager-broker register-api-client --client-name "dcv-api-client" 2>&1)
          if [ $? -eq 0 ]; then
              echo "$(date -u) API client registration output:" | tee -a "$LOG_PATH"
              
              # Extract and save credentials
              CLIENT_ID=$(echo "$API_CLIENT_OUTPUT" | grep "client-id:" | cut -d':' -f2 | tr -d ' ')
              CLIENT_SECRET=$(echo "$API_CLIENT_OUTPUT" | grep "client-password:" | cut -d':' -f2 | tr -d ' ')
              
              # Create directory structure
              mkdir nice-dcv-cli
              cd nice-dcv-cli

              # Download and extract CLI
              wget https://d1uj6qtbmh3dt5.cloudfront.net/nice-dcv-session-manager-cli.zip
              unzip nice-dcv-session-manager-cli.zip

              # Navigate to CLI directory and conf folder
              cd nice-dcv-session-manager-cli-1*
              cd conf

              # Create configuration file with proper variable expansion
              cat > dcvsmcli.conf << EOF
          [output]
          output-format = json

          [security]
          no-verify-ssl = true

          [authentication]
          client-id = $CLIENT_ID
          client-password = $CLIENT_SECRET

          [broker]
          url = https://$PRIVATE_DNS:8443
          EOF

              # Set permissions
              chmod 644 dcvsmcli.conf

              # Add CLI to PATH (using absolute paths)
              CLI_PATH=$(pwd)/..
              CONF_PATH=$(pwd)/dcvsmcli.conf
              
              cat > /etc/profile.d/dcv-sm-cli.sh << EOF
          export PATH=$PATH:$CLI_PATH
          export DCVSM_CONF=$CONF_PATH
          EOF

              chmod +x /etc/profile.d/dcv-sm-cli.sh
              
              # Source the path
              source /etc/profile.d/dcv-sm-cli.sh

              # Verify CLI configuration
              if [ -f "$CONF_PATH" ]; then
                  echo "$(date -u) CLI configuration created successfully" | tee -a "$LOG_PATH"

              else
                  echo "$(date -u) Failed to create CLI configuration" | tee -a "$LOG_PATH"
              fi

          else
              echo "$(date -u) Failed to register API client" | tee -a "$LOG_PATH"
              exit 1
          fi

          echo $(date -u) "*****END USER DATA SCRIPT*****" | tee -a "$LOG_PATH"

  ConnectionGwyLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    DependsOn: SessionMgrInstance
    Properties:
      LaunchTemplateData:
        IamInstanceProfile:
          Arn: !GetAtt ConnectionGwyLaunchTemplateProfile.Arn
        ImageId: !Ref ImageId
        InstanceType: !Ref InstanceType
        KeyName: !Ref KeyName
        SecurityGroupIds:
          - !GetAtt ConnectionGatewaySecurityGroup.GroupId
        BlockDeviceMappings:
          - DeviceName: /dev/xvda
            Ebs:
              VolumeSize: !Ref EbsVolumeSize
              VolumeType: gp3
              Encrypted: true
              # TODO Use CMK
              KmsKeyId: !Sub arn:${AWS::Partition}:kms:${AWS::Region}:${AWS::AccountId}:alias/aws/ebs
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub ${AWS::StackName}-DcvInfraStack/ConnectionGwyLaunchTemplate
          - ResourceType: volume
            Tags:
              - Key: Name
                Value: !Sub ${AWS::StackName}-DcvInfraStack/ConnectionGwyLaunchTemplate
        UserData: 
          Fn::Base64: |
            #!/bin/bash
            set -eE
            LOG_PATH="/var/log/dcv-connection-gateway-install.log"
            echo $(date -u) "*****START USER DATA SCRIPT*****" | tee -a $LOG_PATH

            # Retrieve System Info
            read -r system version <<<$(echo $(cat /etc/os-release | grep "^ID=\|^VERSION_ID=" | sort | cut -d"=" -f2 | tr -d "\"" | tr '[:upper:]' '[:lower:]'))
            major_version="${version%.*}"
            arch="$(arch)"

            # Update system packages
            echo $(date -u) "Updating system packages..." | tee -a "$LOG_PATH"
            dnf update -y

            # Install required packages
            echo $(date -u) "Installing required packages..." | tee -a "$LOG_PATH"
            dnf install -y unzip curl

            # Install AWS CLI
            echo $(date -u) "Installing AWS CLI..." | tee -a "$LOG_PATH"
            if ! command -v aws &> /dev/null; then
                echo $(date -u) "AWS CLI not found. Installing..." | tee -a "$LOG_PATH"
                
                # Create temporary directory for AWS CLI installation
                AWS_CLI_TMP="$(mktemp -d /tmp/aws-cli-XXXXXX)"
                trap 'rm -rf -- "$AWS_CLI_TMP"' ERR
                
                if [ "$arch" = "x86_64" ]; then
                    curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "$AWS_CLI_TMP/awscliv2.zip"
                else
                    curl -s "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "$AWS_CLI_TMP/awscliv2.zip"
                fi
                
                unzip -q "$AWS_CLI_TMP/awscliv2.zip" -d "$AWS_CLI_TMP"
                "$AWS_CLI_TMP/aws/install"
                rm -rf "$AWS_CLI_TMP"
                
                echo $(date -u) "AWS CLI installation completed" | tee -a "$LOG_PATH"
            else
                echo $(date -u) "AWS CLI already installed" | tee -a "$LOG_PATH"
            fi

            # Install SSM Agent
            echo $(date -u) "Installing/Updating SSM Agent..." | tee -a "$LOG_PATH"
            case $system in
                amzn|centos|rhel )
                    if ! systemctl status amazon-ssm-agent &> /dev/null; then
                        if [ "$arch" = "x86_64" ]; then
                            yum install -y https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_amd64/amazon-ssm-agent.rpm
                        else
                            yum install -y https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_arm64/amazon-ssm-agent.rpm
                        fi
                    else
                        systemctl restart amazon-ssm-agent
                    fi
                    ;;
                ubuntu )
                    if ! systemctl status amazon-ssm-agent &> /dev/null; then
                        mkdir -p /tmp/ssm
                        if [ "$arch" = "x86_64" ]; then
                            wget https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/debian_amd64/amazon-ssm-agent.deb -O /tmp/ssm/amazon-ssm-agent.deb
                        else
                            wget https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/debian_arm64/amazon-ssm-agent.deb -O /tmp/ssm/amazon-ssm-agent.deb
                        fi
                        dpkg -i /tmp/ssm/amazon-ssm-agent.deb
                        rm -rf /tmp/ssm
                    else
                        systemctl restart amazon-ssm-agent
                    fi
                    ;;
            esac

            # Enable and start SSM Agent
            systemctl enable amazon-ssm-agent
            systemctl start amazon-ssm-agent
            echo $(date -u) "SSM Agent installation/update completed" | tee -a "$LOG_PATH"

            CLOUDFRONT_PREFIX="https://d1uj6qtbmh3dt5.cloudfront.net"
            TMP_DIR="$(mktemp -d /tmp/XXXXXX)"
            trap 'rm -rf -- "$TMP_DIR"' ERR

            case $system in
                amzn )
                    if [ "$major_version" = 2 ]; then
                        package_type="el7"
                        package_manager="yum"
                        package_extension="rpm"
                    fi
                    ;;
                centos|rhel )
                    if [[ "$major_version" =~ ^(7|8|9) ]]; then
                        package_type="el$major_version"
                        if [[ "$major_version" =~ ^(8|9) ]]; then
                          package_manager="dnf"
                        else
                          package_manager="yum"
                        fi
                        package_extension="rpm"
                    fi
                    ;;
                ubuntu )
                    if [ "$major_version" = 22 ] || [ "$major_version" = 20 ]; then
                        package_type="ubuntu$(echo $version | tr -d '.')"
                        package_manager="apt"
                        package_extension="deb"
                    fi
                    ;;
                * )
                    echo "Error: system '$system' is not supported"
                    exit 1
                    ;;
            esac

            if [ -z "$package_type" ]; then
                echo "Error: system '$system' with version '$version' is not supported for arch '$arch'"
                exit 1
            fi
            echo $(date -u) "Discovered OS:" | tee -a "$LOG_PATH"
            echo $(date -u) "Arch: $arch" | tee -a "$LOG_PATH"
            echo $(date -u) "OS Type: $package_type" | tee -a "$LOG_PATH"
            echo $(date -u) "Package Manager: $package_manager" | tee -a "$LOG_PATH"
            echo $(date -u) "Package Extension: $package_extension" | tee -a "$LOG_PATH"

            # Download Packages
            echo $(date -u) "Downloading DCV Connection Gateway Packages" | tee -a "$LOG_PATH"
            if [ "$package_manager" = apt ]; then
                curl -o "$TMP_DIR/NICE-GPG-KEY" "$CLOUDFRONT_PREFIX/NICE-GPG-KEY"
                gpg --import "$TMP_DIR/NICE-GPG-KEY"
                if [ $arch != "x86_64" ]; then
                    deb_arch="arm64"
                    curl -o "$TMP_DIR/nice-dcv-server.tgz" "$CLOUDFRONT_PREFIX/nice-dcv-ubuntu2204-aarch64.tgz"
                else
                    deb_arch="amd64"
                    curl -o "$TMP_DIR/nice-dcv-server.tgz" "$CLOUDFRONT_PREFIX/nice-dcv-$package_type-$arch.tgz"
                fi
                curl -o "$TMP_DIR/nice-dcv-connection-gateway.$package_extension" "$CLOUDFRONT_PREFIX/nice-dcv-connection-gateway_$deb_arch.$package_type.$package_extension"
            else
                rpm --import "$CLOUDFRONT_PREFIX"/NICE-GPG-KEY
                curl -o "$TMP_DIR/nice-dcv-connection-gateway.$package_extension" "$CLOUDFRONT_PREFIX/nice-dcv-connection-gateway-$package_type.$arch.$package_extension"
                curl -o "$TMP_DIR/nice-dcv-server.tgz" "$CLOUDFRONT_PREFIX/nice-dcv-$package_type-$arch.tgz"
            fi

            # Install Packages
            echo $(date -u) "Installing DCV Connection Gateway" | tee -a "$LOG_PATH"
            tar -xvzf "$TMP_DIR/nice-dcv-server.tgz" -C "$TMP_DIR"
            for package_pattern in "nice-dcv-web-viewer*" "nice-dcv-connection-gateway.$package_extension"; do
                package_full_path=$(find "$TMP_DIR" -name "$package_pattern")
                "$package_manager" install -y "$package_full_path"
            done

            # Enables Web Access through the Gateway
            sed -i --expression 's|url = "https://localhost:8080"|local-resources-path = "/usr/share/dcv/www"|' /etc/dcv-connection-gateway/dcv-connection-gateway.conf

            # Enable and start Gateway
            systemctl enable dcv-connection-gateway
            systemctl start dcv-connection-gateway

            # Clean Up
            rm -rf "$TMP_DIR"

            # Get current region
            TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
            REGION=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/placement/region)
            echo $(date -u) "Current Region: $REGION" | tee -a "$LOG_PATH"

            # Function to safely get SSM parameter
            get_ssm_parameter() {
                local param_name="$1"
                local output
                
                output=$(aws ssm get-parameter --name "$param_name" --region "$REGION" --with-decryption 2>/dev/null)
                if [ $? -eq 0 ]; then
                    echo "$output" | grep -Po '"Value": "\K[^"]*' 2>/dev/null
                    return 0
                else
                    return 1
                fi
            }

            # Function to check if broker is reachable
            check_broker_connectivity() {
                local host="$1"
                local port="$2"
                
                timeout 1 bash -c "echo > /dev/tcp/$host/$port" 2>/dev/null
                return $?
            }

            # Wait for broker DNS parameter and connectivity
            echo $(date -u) "Waiting for broker parameter and connectivity..." | tee -a "$LOG_PATH"

            max_attempts=60  # Total wait time = 60 * 15s = 15 minutes
            attempt=1

            while [ $attempt -le $max_attempts ]; do
                echo $(date -u) "Attempt $attempt $max_attempts: Retrieving broker DNS parameter" | tee -a "$LOG_PATH"
                
                # Try to get the parameter
                BROKER_PRIVATE_DNS=$(get_ssm_parameter "dcv-broker-private-dns")
                
                # Check if we got the parameter and if broker is reachable
                if [ -n "$BROKER_PRIVATE_DNS" ] && check_broker_connectivity "$BROKER_PRIVATE_DNS" 8447; then
                    echo $(date -u) "Success! Broker found and reachable at $BROKER_PRIVATE_DNS" | tee -a "$LOG_PATH"
                    break
                fi
                
                # If we're here, either parameter wasn't found or broker wasn't reachable
                if [ -z "$BROKER_PRIVATE_DNS" ]; then
                    echo $(date -u) "Parameter not found yet, waiting 15s before retry..." | tee -a "$LOG_PATH"
                else
                    echo $(date -u) "Broker at $BROKER_PRIVATE_DNS is not reachable yet, waiting 15s..." | tee -a "$LOG_PATH"
                fi
                
                sleep 15
                attempt=$((attempt+1))
            done

            if [ $attempt -gt $max_attempts ]; then
                echo $(date -u) "ERROR: Maximum attempts reached. Could not connect to broker." | tee -a "$LOG_PATH"
                exit 1
            fi

            echo $(date -u) "Broker is ready at $BROKER_PRIVATE_DNS" | tee -a "$LOG_PATH"

            # Port Configuration. Using hex to escape double quotes: \x22 = "
            echo $(date -u) "Configuring Connection Gateway..." | tee -a "$LOG_PATH"
            sed -i "s/^#\[health-check\]/\[health-check\]/g" /etc/dcv-connection-gateway/dcv-connection-gateway.conf
            sed -i --expression 's|#bind-addr = "::"|bind-addr = "::"|' /etc/dcv-connection-gateway/dcv-connection-gateway.conf
            sed -i --expression 's|#tls-strict = false|tls-strict = false|' /etc/dcv-connection-gateway/dcv-connection-gateway.conf
            sed -i "/\[resolver\]/a tls-strict = false" /etc/dcv-connection-gateway/dcv-connection-gateway.conf
            sed -i "/bind-addr = \"::\"/a port = 8989" /etc/dcv-connection-gateway/dcv-connection-gateway.conf
            sed -i "s|url = \"https://localhost:8081\"|url = \"https://$BROKER_PRIVATE_DNS:8447\"|" /etc/dcv-connection-gateway/dcv-connection-gateway.conf

            # Start DCV Connection Gateway Service
            echo $(date -u) "Starting and Enabling Connection Gateway service..." | tee -a "$LOG_PATH"
            systemctl restart dcv-connection-gateway.service

            # Log if successful installation
            if [[ $? -eq 0 ]]; then
                echo $(date -u) "Successfully installed DCV Connection Gateway" | tee -a "$LOG_PATH"
            else
                echo $(date -u) "There was an error during DCV Connection Gateway installation" | tee -a "$LOG_PATH"
            fi
            echo $(date -u) "*****END USER DATA SCRIPT*****" | tee -a "$LOG_PATH"

# Auto Scaling Group and Load Balancer
  ConnectionGwyASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      LaunchTemplate:
        LaunchTemplateId: !Ref ConnectionGwyLaunchTemplate
        Version: !GetAtt ConnectionGwyLaunchTemplate.LatestVersionNumber
      MinSize: !Ref AutoScalingMinSize
      MaxSize: !Ref AutoScalingMaxSize
      DesiredCapacity: !Ref AutoScalingDesiredCapacity
      TargetGroupARNs:
        - !Ref ConnectionGwyNLBTargetGroup
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: 1
        MaxBatchSize: 1

  ConnectionGwyASGScalingPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AutoScalingGroupName: !Ref ConnectionGwyASG
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ASGAverageCPUUtilization
        TargetValue: !Ref CpuUtilizationTarget

  ConnectionGwyNLB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Type: network
      Scheme: internet-facing
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      LoadBalancerAttributes:
        - Key: deletion_protection.enabled
          Value: 'false'
        - Key: load_balancing.cross_zone.enabled
          Value: 'true'
      Name: !Sub ${AWS::StackName}-nlb

  ConnectionGwyNLBConnectionGwyNLBListener9EA5A2A4:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ConnectionGwyNLBTargetGroup
      LoadBalancerArn: !Ref ConnectionGwyNLB
      Port: 8443
      Protocol: TCP_UDP

  ConnectionGwyNLBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 30
      HealthCheckPort: '8989'
      HealthCheckProtocol: TCP
      HealthyThresholdCount: 5
      Port: 8443
      Protocol: TCP_UDP
      TargetType: instance
      UnhealthyThresholdCount: 5
      VpcId: !Ref VPC

  DCVServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for DCV Fleet Servers
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - Description: Allow DCV streaming traffic from Gateway
          FromPort: 8443
          ToPort: 8443
          IpProtocol: tcp
          SourceSecurityGroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
        - Description: Allow DCV streaming traffic (UDP)
          FromPort: 8443
          ToPort: 8443
          IpProtocol: udp
          SourceSecurityGroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
        - Description: Allow SSM access from VPC
          FromPort: 443
          ToPort: 443
          IpProtocol: tcp
          CidrIp: !Ref VpcCidr
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DCVServerSecurityGroup

  DCVFleetServerLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    DependsOn: SessionMgrInstance
    CreationPolicy:
      ResourceSignal:
        Timeout: PT90M
    Properties:
      LaunchTemplateData:
        ImageId: !Ref ImageId
        InstanceType: !Ref InstanceType
        IamInstanceProfile: 
          Arn: !GetAtt DCVFleetServerInstanceProfile.Arn
        KeyName: !Ref KeyName
        SecurityGroupIds:
          - !Ref DCVServerSecurityGroup
        UserData:
          Fn::Base64: |
            #!/bin/bash
            set -eE
            LOG_PATH="/var/log/dcv-connection-gateway-install.log"
            echo $(date -u) "*****START USER DATA SCRIPT*****" | tee -a $LOG_PATH

            # Retrieve System Info
            read -r system version <<<$(echo $(cat /etc/os-release | grep "^ID=\|^VERSION_ID=" | sort | cut -d"=" -f2 | tr -d "\"" | tr '[:upper:]' '[:lower:]'))
            major_version="${version%.*}"
            arch="$(arch)"

            # Update system packages
            echo $(date -u) "Updating system packages..." | tee -a "$LOG_PATH"
            dnf update -y

            # Install required packages
            echo $(date -u) "Installing required packages..." | tee -a "$LOG_PATH"
            dnf install -y unzip curl

            # Install AWS CLI
            echo $(date -u) "Installing AWS CLI..." | tee -a "$LOG_PATH"
            if ! command -v aws &> /dev/null; then
                echo $(date -u) "AWS CLI not found. Installing..." | tee -a "$LOG_PATH"
                
                # Create temporary directory for AWS CLI installation
                AWS_CLI_TMP="$(mktemp -d /tmp/aws-cli-XXXXXX)"
                trap 'rm -rf -- "$AWS_CLI_TMP"' ERR
                
                if [ "$arch" = "x86_64" ]; then
                    curl -s "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "$AWS_CLI_TMP/awscliv2.zip"
                else
                    curl -s "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "$AWS_CLI_TMP/awscliv2.zip"
                fi
                
                unzip -q "$AWS_CLI_TMP/awscliv2.zip" -d "$AWS_CLI_TMP"
                "$AWS_CLI_TMP/aws/install" --update
                rm -rf "$AWS_CLI_TMP"
                
                echo $(date -u) "AWS CLI installation completed" | tee -a "$LOG_PATH"
            else
                echo $(date -u) "AWS CLI already installed" | tee -a "$LOG_PATH"
            fi

            # Install SSM Agent
            echo $(date -u) "Installing/Updating SSM Agent..." | tee -a "$LOG_PATH"
            case $system in
                amzn|centos|rhel )
                    if ! systemctl status amazon-ssm-agent &> /dev/null; then
                        if [ "$arch" = "x86_64" ]; then
                            yum install -y https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_amd64/amazon-ssm-agent.rpm
                        else
                            yum install -y https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/linux_arm64/amazon-ssm-agent.rpm
                        fi
                    else
                        systemctl restart amazon-ssm-agent
                    fi
                    ;;
                ubuntu )
                    if ! systemctl status amazon-ssm-agent &> /dev/null; then
                        mkdir -p /tmp/ssm
                        if [ "$arch" = "x86_64" ]; then
                            wget https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/debian_amd64/amazon-ssm-agent.deb -O /tmp/ssm/amazon-ssm-agent.deb
                        else
                            wget https://s3.amazonaws.com/ec2-downloads-windows/SSMAgent/latest/debian_arm64/amazon-ssm-agent.deb -O /tmp/ssm/amazon-ssm-agent.deb
                        fi
                        dpkg -i /tmp/ssm/amazon-ssm-agent.deb
                        rm -rf /tmp/ssm
                    else
                        systemctl restart amazon-ssm-agent
                    fi
                    ;;
            esac

            # Enable and start SSM Agent
            systemctl enable amazon-ssm-agent
            systemctl start amazon-ssm-agent
            echo $(date -u) "SSM Agent installation/update completed" | tee -a "$LOG_PATH"

            aws s3 cp s3://dcv-resources-789438508852/rhel-dcv-server-setup1.sh .
            chmod +x rhel-dcv-server-setup1.sh
            ./rhel-dcv-server-setup1.sh
            echo $(date -u) "DCV Server Setup 1 completed" | tee -a "$LOG_PATH"

            aws s3 cp s3://dcv-resources-789438508852/rhel-dcv-server-setup2.sh .
            chmod +x rhel-dcv-server-setup2.sh
            ./rhel-dcv-server-setup2.sh
            echo $(date -u) "DCV Server Setup 2 completed" | tee -a "$LOG_PATH"

            aws s3 cp s3://dcv-resources-789438508852/rhel-dcv-session-manager-agent.sh .
            chmod +x rhel-dcv-session-manager-agent.sh
            ./rhel-dcv-session-manager-agent.sh
            echo $(date -u) "DCV Session Manager Agent completed" | tee -a "$LOG_PATH"














  DCVFleetServerASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      LaunchTemplate:
        LaunchTemplateId: !Ref DCVFleetServerLaunchTemplate
        Version: !GetAtt DCVFleetServerLaunchTemplate.LatestVersionNumber
      MinSize: !Ref AutoScalingMinSize
      MaxSize: !Ref AutoScalingMaxSize
      DesiredCapacity: !Ref AutoScalingDesiredCapacity
      HealthCheckType: EC2
      HealthCheckGracePeriod: 300
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DCVFleetServer
          PropagateAtLaunch: true
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: 1
        MaxBatchSize: 1

  DCVFleetServerScalingPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AutoScalingGroupName: !Ref DCVFleetServerASG
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ASGAverageCPUUtilization
        TargetValue: !Ref CpuUtilizationTarget
  WinDCVServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for DCV Fleet Servers
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - Description: Allow DCV streaming traffic from Gateway
          FromPort: 8443
          ToPort: 8443
          IpProtocol: tcp
          SourceSecurityGroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
        - Description: Allow DCV streaming traffic (UDP)
          FromPort: 8443
          ToPort: 8443
          IpProtocol: udp
          SourceSecurityGroupId: !GetAtt ConnectionGatewaySecurityGroup.GroupId
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-DCVServerSecurityGroup

  WinDCVFleetServerLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    DependsOn: SessionMgrInstance
    Properties:
      LaunchTemplateName: !Sub ${AWS::StackName}-DCVFleetServerLaunchTemplate
      LaunchTemplateData:
        ImageId: !Ref WindowsServerAmiId
        InstanceType: m5.xlarge
        IamInstanceProfile:
          Arn: !GetAtt DCVFleetServerInstanceProfile.Arn
        SecurityGroupIds: 
          - !Ref WinDCVServerSecurityGroup
        KeyName: !Ref KeyName
        UserData: 
          Fn::Base64: |
            <powershell>

            # Start Logging
            Start-Transcript -Path C:\Windows\Temp\dcv-userdata.log -Append

            # Get Session Manager DNS from SSM Parameter Store
            $token = Invoke-RestMethod -Headers @{'X-aws-ec2-metadata-token-ttl-seconds' = '21600'} -Method PUT -Uri http://169.254.169.254/latest/api/token
            $region = Invoke-RestMethod -Headers @{'X-aws-ec2-metadata-token' = $token} -Method GET -Uri http://169.254.169.254/latest/meta-data/placement/region
            $SessMgrDNS = (Get-SSMParameter -Name "dcv-broker-private-dns" -Region $region).Value
            $BrokerAgentConnectionPort = "8445"

            $instanceType = Invoke-RestMethod -Headers @{'X-aws-ec2-metadata-token' = $token} -Method GET -Uri http://169.254.169.254/latest/meta-data/instance-type
            $OSVersion = ((Get-ItemProperty -Path "Microsoft.PowerShell.Core\Registry::\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -Name ProductName).ProductName) -replace  "[^0-9]" , ''
            if(($OSVersion -eq "2016") -and (($InstanceType[0] -ne 'g') -or ($InstanceType[0] -ne 'p'))){
                $VirtualDisplayDriverRequired = $true
            }

            # Check and install Visual C++ prerequisite
            $InstalledSoftware = (Get-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*) | Where-Object {$_.DisplayName -like "Microsoft Visual C++ 2022*"}
            if($InstalledSoftware.count -eq 0){
                Start-Job -Name VcWebReq -ScriptBlock { Invoke-WebRequest -uri https://aka.ms/vs/17/release/vc_redist.x64.exe -OutFile C:\Windows\Temp\vc_redist_64.exe }  
                Wait-Job -Name VcWebReq
                Invoke-Command -ScriptBlock { . C:\Windows\Temp\vc_redist_64.exe /install /passive /norestart }
            }

            # Download Package(s)
            Write-Host "Downloading DCV packages..."
            if($VirtualDisplayDriverRequired){
                Start-Job -Name WebReq -ScriptBlock { Invoke-WebRequest -uri https://d1uj6qtbmh3dt5.cloudfront.net/nice-dcv-virtual-display-x64-Release.msi -OutFile C:\Windows\Temp\DCVDisplayDriver.msi ; Invoke-WebRequest -uri https://d1uj6qtbmh3dt5.cloudfront.net/nice-dcv-server-x64-Release.msi -OutFile C:\Windows\Temp\DCVServer.msi }  
            }else{
                Start-Job -Name WebReq -ScriptBlock { Invoke-WebRequest -uri https://d1uj6qtbmh3dt5.cloudfront.net/nice-dcv-server-x64-Release.msi -OutFile C:\Windows\Temp\DCVServer.msi }  
            }
            Wait-Job -Name WebReq

            # Install Package(s)
            Write-Host "Installing DCV packages..."
            if($VirtualDisplayDriverRequired){
                Invoke-Command -ScriptBlock {Start-Process "msiexec.exe" -ArgumentList "/I C:\Windows\Temp\DCVDisplayDriver.msi /quiet /norestart" -Wait}
            }
            Write-Host "Installing DCV Server..."
            Invoke-Command -ScriptBlock {Start-Process "msiexec.exe" -ArgumentList "/I C:\Windows\Temp\DCVServer.msi ADDLOCAL=ALL /quiet /norestart /l*v dcv_install_msi.log " -Wait}
            while (-not(Get-Service dcvserver -ErrorAction SilentlyContinue)) { Start-Sleep -Milliseconds 250 }

            $dcvPath = "Microsoft.PowerShell.Core\Registry::\HKEY_USERS\S-1-5-18\Software\GSettings\com\nicesoftware\dcv"
            Set-ItemProperty -Path "$dcvPath\session-management" -Name create-session -Value 0 -force

            # # Configure DCV Server
            # Write-Host "Configuring DCV Server..."
            # $dcvPath = "Microsoft.PowerShell.Core\Registry::\HKEY_USERS\S-1-5-18\Software\GSettings\com\nicesoftware\dcv"

            # # Configure DCV Security Settings
            # Write-Host "Configuring DCV security settings..."
            # # Enable both password and token authentication
            # Set-ItemProperty -Path "$dcvPath\security" -Name "authentication" -Value "system" -Force
            # Set-ItemProperty -Path "$dcvPath\security" -Name "authentication-methods" -Value "password,token" -Force
            # New-ItemProperty -Path "$dcvPath\security" -Name "auth-token-verifier" -Value "https://$SessMgrDNS`:$BrokerAgentConnectionPort/agent/validate-authentication-token" -Force
            # New-ItemProperty -Path "$dcvPath\security" -Name no-tls-strict -PropertyType DWORD -Value 1 -force

            $dcvPath = "Microsoft.PowerShell.Core\Registry::\HKEY_USERS\S-1-5-18\Software\GSettings\com\nicesoftware\dcv"

            # Configure security settings for both password and token authentication
            $securitySettings = @{
                "authentication" = "system"                        # Use system authentication
                "authentication-methods" = "password,token"        # Enable both password and token
                "auth-token-verifier" = "https://$SessMgrDNS`:$BrokerAgentConnectionPort/agent/validate-authentication-token"
                "no-tls-strict" = 1                               # Disable strict TLS verification
            }

            # Apply settings
            foreach ($setting in $securitySettings.GetEnumerator()) {
                if ($setting.Value -is [int]) {
                    Set-ItemProperty -Path "$dcvPath\security" -Name $setting.Key -Value $setting.Value -Type DWord -Force
                } else {
                    Set-ItemProperty -Path "$dcvPath\security" -Name $setting.Key -Value $setting.Value -Force
                }
            }

            # Verify settings
            Write-Host "Verifying DCV security settings..."
            $currentSettings = Get-ItemProperty -Path "$dcvPath\security"
            Write-Host "Authentication: $($currentSettings.authentication)"
            Write-Host "Authentication Methods: $($currentSettings.'authentication-methods')"
            Write-Host "Token Verifier: $($currentSettings.'auth-token-verifier')"

            # Set the maximum number of concurrent users
            Write-Host "Configuring maximum concurrent users..."
            $MaxConcurrentUsers = 10

            # Create connectivity key if it doesn't exist
            $connectivityPath = "$dcvPath\connectivity"
            if (!(Test-Path $connectivityPath)) {
                New-Item -Path $connectivityPath -Force | Out-Null
            }

            # Set max concurrent clients
            Set-ItemProperty -Path $connectivityPath -Name "max-concurrent-clients" -Value $MaxConcurrentUsers -Type DWord -Force

            Write-Host "Maximum concurrent users set to: $MaxConcurrentUsers"

            # Stop DCV Server
            Write-Host "Stopping DCV Server service..."
            Stop-Service dcvserver

            Start-Job -Name SMWebReq -ScriptBlock { Invoke-WebRequest -uri https://d1uj6qtbmh3dt5.cloudfront.net/nice-dcv-session-manager-agent-x64-Release.msi -OutFile C:\Windows\Temp\DCVSMAgent.msi }  
            Wait-Job -Name SMWebReq
            Invoke-Command -ScriptBlock {Start-Process "msiexec.exe" -ArgumentList "/I C:\Windows\Temp\DCVSMAgent.msi /quiet /norestart " -Wait}
            while (-not(Get-Service DcvSessionManagerAgentService -ErrorAction SilentlyContinue)) { Start-Sleep -Milliseconds 250 }
            Stop-Service DcvSessionManagerAgentService

            # SET AGENT.CONF
            $AgentConfContent = "version = '0.1'
            [agent]
            broker_host = '$SessMgrDNS'
            broker_port = $BrokerAgentConnectionPort
            tls_strict = false
            broker_update_interval = 15
            [log]
            level = 'debug'
            rotation = 'daily'
            "
            $AgentConfFolder = "C:\Program Files\NICE\DCVSessionManagerAgent\conf"
            New-Item -Path $AgentConfFolder -Name "agent.conf" -ItemType File -Force -Value "$AgentConfContent"

            Set-Service -Name DcvSessionManagerAgentService -StartupType Automatic
            Start-Service dcvserver
            Start-Service DcvSessionManagerAgentService
            </powershell>

  WinDCVFleetServerASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      VPCZoneIdentifier:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      LaunchTemplate:
        LaunchTemplateId: !Ref WinDCVFleetServerLaunchTemplate
        Version: !GetAtt WinDCVFleetServerLaunchTemplate.LatestVersionNumber
      MinSize: !Ref AutoScalingMinSize
      MaxSize: !Ref AutoScalingMaxSize
      DesiredCapacity: !Ref AutoScalingDesiredCapacity
      HealthCheckType: EC2
      HealthCheckGracePeriod: 300
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-WinDCVFleetServer
          PropagateAtLaunch: true
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MinInstancesInService: 1
        MaxBatchSize: 1

  WinDCVFleetServerScalingPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AutoScalingGroupName: !Ref WinDCVFleetServerASG
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ASGAverageCPUUtilization
        TargetValue: 70.0
Outputs:

  ConnectionGatewayURL:
    Description: URL for DCV Connection Gateway
    Value: !Sub https://${ConnectionGwyNLB.DNSName}:8443

  DCVConnectionStringTemplate:
    Description: Template for DCV connection string
    Value: !Sub ${ConnectionGwyNLB.DNSName}:8443/?authToken=<TOKEN>#<SESSION-ID>

  DCVConnectionInstructions:
    Description: Instructions for connecting to DCV
    Value: !Sub |
      To connect to DCV:
      1. Download DCV Client from: https://download.nice-dcv.com/
      2. Connect to: ${ConnectionGwyNLB.DNSName}:8443
      3. Login with:
        Username: dcvuser
        Password: Use the password you configured
      Note: Both password and token authentication are enabled.
