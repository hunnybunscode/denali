AWSTemplateFormatVersion: "2010-09-09"
Description: |
  Creates a source S3 bucket with KMS encryption, Lambda function for object copying, and necessary IAM roles and permissions for secure cross-account access.
  Objects uploaded to this Source Bucket are automatically copied to the Ingestion Bucket in the Validation Account.

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Source Bucket Configuration"
        Parameters:
          - SourceBucketName
          - ObjectExpirationInDays
          - DeleteSourceObjects
      - Label:
          default: "Destination Bucket Configuration"
        Parameters:
          - DestinationBucketName
          - DestinationBucketKeyArn
    ParameterLabels:
      SourceBucketName:
        default: Source Bucket Name
      ObjectExpirationInDays:
        default: Object Expiration
      DeleteSourceObjects:
        default: Delete Source Objects
      DestinationBucketName:
        default: Destination Bucket Name
      DestinationBucketKeyArn:
        default: Destination Bucket Key ARN

Parameters:
  SourceBucketName:
    Type: String
    Description: Name for the source S3 bucket
    AllowedPattern: ^[a-z0-9.\-]{3,63}$
    ConstraintDescription: Must be between 3 and 63 characters, and contain only lowercase letters, numbers, periods (.), and hyphens (-).

  DestinationBucketName:
    Type: String
    Description: Name of the destination bucket
    AllowedPattern: ^[a-z0-9.\-]{3,63}$
    ConstraintDescription: Must be between 3 and 63 characters, and contain only lowercase letters, numbers, periods (.), and hyphens (-).

  DestinationBucketKeyArn:
    Type: String
    Description: Name of the destination bucket KMS Key Arn
    AllowedPattern: ^arn:(aws|aws-us-gov):kms:[a-z0-9\-]+:[0-9]{12}:key\/[a-z0-9\-]{36}$
    ConstraintDescription: Must be a valid KMS Key Arn

  ObjectExpirationInDays:
    Type: Number
    Description: Enter the number of days you want to keep objects in the Ingestion Bucket.
    Default: 30
    MinValue: 1

  DeleteSourceObjects:
    Type: String
    Description: Should source objects be deleted after successful copy?
    AllowedValues:
      - true
      - false
    Default: false

Conditions:
  EnabledDeleteSourceObjects: !Equals
    - !Ref DeleteSourceObjects
    - true

Resources:
  EncryptionKey:
    Type: AWS::KMS::Key
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      Description: KMS key for S3 bucket and Lambda encryption
      EnableKeyRotation: true
      KeyPolicy:
        Version: "2012-10-17"
        Id: key-default-1
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:root
            Action: kms:*
            Resource: "*"
          - Sid: Allow logs service principal to use the key
            Effect: Allow
            Principal:
              Service: !Sub logs.${AWS::Region}.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: "*"

  EncryptionKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub alias/${AWS::StackName}-key
      TargetKeyId: !Ref EncryptionKey

  SourceBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref SourceBucketName
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !GetAtt EncryptionKey.Arn
            BucketKeyEnabled: true
      PublicAccessBlockConfiguration:
        BlockPublicAcls: True
        BlockPublicPolicy: True
        IgnorePublicAcls: True
        RestrictPublicBuckets: True
      LifecycleConfiguration:
        Rules:
          - Id: ExpireObjectsLifecycleRule
            Status: Enabled
            ExpirationInDays: !Ref ObjectExpirationInDays
            NoncurrentVersionExpiration:
              NoncurrentDays: 1
          - Id: ExpiredObjectDeleteMarkerLifecycleRule
            Status: Enabled
            ExpiredObjectDeleteMarker: true
      NotificationConfiguration:
        LambdaConfigurations:
          - Event: s3:ObjectCreated:*
            Function: !GetAtt CopyObjectFunction.Arn

  SourceBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref SourceBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: Restrict to TLS requests only
            Effect: Deny
            Principal: "*"
            Action: s3:*
            Resource:
              - !Sub ${SourceBucket.Arn}
              - !Sub ${SourceBucket.Arn}/*
            Condition:
              Bool:
                aws:SecureTransport: false
          - Sid: AllowLambdaGetObject
            Effect: Allow
            Principal:
              AWS: !GetAtt LambdaExecutionRole.Arn
            Action:
              - s3:GetObject
              - s3:GetObjectVersion
            Resource: !Sub ${SourceBucket.Arn}/*

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3AccessPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:GetObjectVersion
                  - s3:ListBucket
                  - !If
                    - EnabledDeleteSourceObjects
                    - s3:DeleteObject
                    - !Ref AWS::NoValue
                Resource:
                  - !Sub arn:${AWS::Partition}:s3:::${SourceBucketName}/*
                  - !Sub arn:${AWS::Partition}:s3:::${SourceBucketName}
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub arn:${AWS::Partition}:s3:::${DestinationBucketName}/*
        - PolicyName: KMSAccessPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - kms:Decrypt
                Resource: !GetAtt EncryptionKey.Arn
        - PolicyName: KMSAccessPolicyDestinationBucket
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - kms:GenerateDataKey
                Resource: !Ref DestinationBucketKeyArn

  CopyObjectFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.11
      Timeout: 900
      MemorySize: 256
      Environment:
        Variables:
          DESTINATION_BUCKET: !Ref DestinationBucketName
          DELETE_SOURCE_OBJECTS: !Ref DeleteSourceObjects
      KmsKeyArn: !GetAtt EncryptionKey.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          from botocore.exceptions import ClientError
          from urllib.parse import unquote_plus

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          S3_CLIENT = boto3.client("s3")
          DELETE_SOURCE_OBJECTS = os.environ['DELETE_SOURCE_OBJECTS'].lower() == 'true'

          def delete_source_object(bucket, key):
              try:
                  S3_CLIENT.delete_object(Bucket=bucket, Key=key)
                  logger.info(f"Successfully deleted {key} from {bucket}")
                  return True
              except ClientError as e:
                  logger.error(f"Error deleting object {key} from {bucket}: {str(e)}")
                  raise e

          def copy_object(source_bucket, destination_bucket, object_key):
              try:
                  copy_source = {'Bucket': source_bucket, 'Key': object_key}
                  S3_CLIENT.copy_object(
                      CopySource=copy_source,
                      Bucket=destination_bucket,
                      Key=object_key
                  )
                  logger.info(f"Successfully copied {object_key} to {destination_bucket}")
                  return True
              except ClientError as e:
                  logger.error(f"Error copying object {object_key}: {str(e)}")
                  raise e

          def handler(event, context):
              logger.info(f"Event: {json.dumps(event, default=str)}")

              source_bucket = event['Records'][0]['s3']['bucket']['name']
              object_key = unquote_plus(event['Records'][0]['s3']['object']['key'])
              destination_bucket = os.environ['DESTINATION_BUCKET']

              try:
                  logger.info(f"Copying {object_key} from {source_bucket} to {destination_bucket}")

                  # Copy the object to destination
                  if copy_object(source_bucket, destination_bucket, object_key):
                      action = 'copied'
                      # If copy was successful and deletion is enabled, delete from source
                      if DELETE_SOURCE_OBJECTS:
                          delete_source_object(source_bucket, object_key)
                          action = 'copied and deleted'

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Object processed successfully',
                          'source': f"{source_bucket}/{object_key}",
                          'destination': f"{destination_bucket}/{object_key}",
                          'action': action
                      })
                  }

              except ClientError as e:
                  error_code = e.response['Error']['Code']
                  error_message = e.response['Error']['Message']
                  logger.error(f"AWS Error processing object: {error_code} - {error_message}")
                  if error_code in ['AccessDenied', 'InvalidAccessKeyId', 'SignatureDoesNotMatch']:
                      logger.error("This might be a permissions issue with the bucket")
                  raise e
              except Exception as e:
                  logger.error(f"Unexpected error: {str(e)}")
                  raise e

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref CopyObjectFunction
      Action: lambda:InvokeFunction
      Principal: s3.amazonaws.com
      SourceArn: !Sub arn:${AWS::Partition}:s3:::${SourceBucketName}
      SourceAccount: !Ref "AWS::AccountId"

  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/${CopyObjectFunction}
      RetentionInDays: 90
      KmsKeyId: !GetAtt EncryptionKey.Arn

Outputs:
  LambdFunctionRoleArn:
    Value: !GetAtt LambdaExecutionRole.Arn
    Description: ARN of the Lambda function execution role
