AWSTemplateFormatVersion: 2010-09-09

Description: Creates an EC2 Image Builder image pipeline

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: General
        Parameters:
          - IamPrefix
          - PermissionsBoundaryPolicyArn
          - ResourceSuffix
          - AvScanMode
          - ProxyServerAddress
          - EmailEndPoint

      - Label:
          default: Templates Location
        Parameters:
          - TemplateBucketName
          - TemplatePrefix

      - Label:
          default: Image Builder
        Parameters:
          - SemVer
          - ParentImage
          - SourceAccountId
          - ImageNamePattern
          - RequiredImageDescriptionPattern
          - ImageCheckFrequency
          - BypassGpgCheck
          - VpcId
          - SubnetId
          - OutboundCidrIp

    ParameterLabels:
      IamPrefix:
        default: IAM Resource Prefix
      PermissionsBoundaryPolicyArn:
        default: Permissions Boundary Policy ARN
      ResourceSuffix:
        default: Resource Suffix
      AvScanMode:
        default: Anti-Virus Scan Mode
      ProxyServerAddress:
        default: Proxy Server Address
      EmailEndPoint:
        default: Email Notification
      SemVer:
        default: Semantic Version
      ParentImage:
        default: Parent Image
      ImageNamePattern:
        default: Image Name Pattern
      RequiredImageDescriptionPattern:
        default: Required Image Description Pattern
      ImageCheckFrequency:
        default: Image Check Frequency
      BypassGpgCheck:
        default: Bypass GPG Check
      VpcId:
        default: VPC ID
      SubnetId:
        default: Subnet ID
      OutboundCidrIp:
        default: Outbound CIDR
      SourceAccountId:
        default: Source Account ID
      TemplateBucketName:
        default: Template Bucket Name
      TemplatePrefix:
        default: Template Prefix

Parameters:
  IamPrefix:
    Type: String
    Description: Required prefix for IAM resources
    Default: AFC2S
    AllowedValues: [AFC2S]
    ConstraintDescription: Must be "AFC2S"

  PermissionsBoundaryPolicyArn:
    Type: String
    Description: ARN of the policy that is used to set the permissions boundary for IAM resources
    AllowedPattern: ^arn:(aws|aws-us-gov):iam::(\d{12}|aws):policy/.*
    ConstraintDescription: Must be a valid IAM policy ARN

  ResourceSuffix:
    Type: String
    Description: >-
      Suffix added to the named AWS resources. It must start with a lowercase letter and contain
      only lowercase letters, numbers, and hyphens; its length cannot exceed 20.
    AllowedPattern: ^[a-z][a-z0-9-]{0,19}$
    ConstraintDescription: Must start with a lowercase letter and contain only lowercase letters, numbers, and hyphens; its length cannot exceed 20.

  AvScanMode:
    Type: String
    Description: Select "Test" to simulate anti-virus scanning; otherwise, select "Live"
    Default: Live
    AllowedValues: [Test, Live]
    ConstraintDescription: Must be either "Test" or "Live"

  ProxyServerAddress:
    Type: String
    Description: The address of the proxy server for outbound internet access. It can be an http or IP address. The port is fixed at 3128
    AllowedPattern: ^(?!.*(:[0-9]{1,5}))(https?://([a-zA-Z0-9-_.]+)|((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])))$
    ConstraintDescription: Must be a valid http or IP address, without the port number

  EmailEndPoint:
    Type: String
    Description: "The email address at which to receive notifications for ImageBuilder events"
    AllowedPattern: ^$|^\S+@\S+\.+\S+$
    ConstraintDescription: Must be left blank or a valid email address

  SemVer:
    Type: String
    Description: >
      Semantic version of the Diode Image Recipe and other associated resources. Increment this when updating the parent image below or any associated resources in the template itself.
      The format is <major>.<minor>.<patch> where each component is an integer (e.g. 1.0.0).
    Default: "1.0.0"

  ParentImage:
    Type: String
    Description: The parent (or base) image for the image recipe, in either an Image ARN or an AMI ID format.
    AllowedPattern: ^(arn:(aws|aws-us-gov):ec2:\S{1,30}::image\/)?ami-([a-f0-9]{8}|[a-f0-9]{17})$
    ConstraintDescription: Must be a valid Image ARN or AMI ID

  ImageNamePattern:
    Type: String
    Description: >-
      The base image name pattern for image builder output images.
      This pattern is used to identify the correct source AMI.
      The pattern must exactly match part of the AMI name.
    Default: "V12E_RHEL8_Agents_Gold"
    AllowedPattern: "^[a-zA-Z0-9_-]+$"
    ConstraintDescription: "Pattern must contain only alphanumeric characters, underscores, and hyphens"

  RequiredImageDescriptionPattern:
    Type: CommaDelimitedList
    Description: >-
      Comma-separated list of required patterns that must be present in the image description.
      These patterns are used to identify the correct source AMI that contains specific
      software components (e.g., ClamAV, Nessus).
    Default: Yum,ClamAV,Nessus
    ConstraintDescription: "Must be a comma-separated list of patterns"

  ImageCheckFrequency:
    Type: String
    Description: >-
      The frequency to run the check for new base image shared from source account. For valid values, go to https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-scheduled-rule-pattern.html.
      You can leave this blank if you want to manually check for new AMIs.
    Default: rate(1 day)
    AllowedPattern: ^$|^cron\(.*\)$|^rate\([1-9]\d* (minute|minutes|hour|hours|day|days)\)$
    ConstraintDescription: Must be left blank; or a valid cron or rate expression (https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-scheduled-rule-pattern.html)

  BypassGpgCheck:
    Type: String
    Description: Select "true" to bypass GPG check for SSM Agent installation file; otherwise, select "false"
    Default: "false"
    AllowedValues: ["true", "false"]
    ConstraintDescription: Must be either "true" or "false"

  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID
    AllowedPattern: \S+
    ConstraintDescription: Must select a VPC

  SubnetId:
    Type: AWS::EC2::Subnet::Id
    Description: The ID of the subnet in which EC2 instances launched by the image pipeline will run.
    AllowedPattern: \S+
    ConstraintDescription: Must select a subnet

  OutboundCidrIp:
    Type: String
    Description: Outbound CIDR block for ImageBuilder instances
    Default: 0.0.0.0/0
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/([0-9]|[1-2][0-9]|3[0-2]))$
    ConstraintDescription: Must be a valid CIDR block

  SourceAccountId:
    Type: String
    Description: AWS Account ID that owns the Parent Image (AMI)
    AllowedPattern: ^\d{12}$
    ConstraintDescription: Must be a valid 12-digit AWS account ID

  TemplateBucketName:
    Type: String
    Description: Name of S3 bucket that contains the CloudFormation templates

  TemplatePrefix:
    Type: String
    Description: The prefix for the CloudFormation templates.
    AllowedPattern: ^[a-zA-Z0-9_-]+(/[a-zA-Z0-9_-]+)*$
    ConstraintDescription: Cannot start or end with a slash(/). Must be a valid path (e.g. my/path or my-path)

Resources:
  BuildComponentPrepareImage:
    Type: AWS::ImageBuilder::Component
    Properties:
      Name: !Sub prepare-image-${ResourceSuffix}
      Description: Prepares the image for data transfer pipeline
      Version: !Ref SemVer
      Platform: Linux
      SupportedOsVersions:
        - Red Hat Enterprise Linux 8
        - Red Hat Enterprise Linux 9
      KmsKeyId: !GetAtt ImageBuilderKmsKey.Arn
      ## If there is only one phase, and its name is "test", then the type is TEST. For all other components, the type is BUILD.
      Data: !Sub |
        name: Prepare image for data transfer pipeline
        description: Prepares image for data transfer pipeline
        schemaVersion: 1.0
        phases:
          - name: build
            steps:
              - name: PrepImage
                action: ExecuteBash
                inputs:
                  commands:
                    # Set environment variables for proxy servers
                    - export http_proxy=${ProxyServerAddress}:3128
                    - export https_proxy=${ProxyServerAddress}:3128
                    - export no_proxy='169.254.169.254,vi2e.io,s3.${AWS::Region}.amazonaws.com'

                    # Install python3.11, pip, and other libraries
                    - yum install -y python3.11 python3.11-pip curl unzip
                    - python3.11 -m pip install pip --upgrade
                    - python3.11 -m pip install boto3 puremagic pyjwt

                    # Update all packages
                    - yum update -y

                    # Install awscli
                    - ARCH=$(uname -m)
                    - curl "https://awscli.amazonaws.com/awscli-exe-linux-$ARCH.zip" -o /tmp/awscliv2.zip
                    - echo Unzipping awscliv2.zip
                    - unzip -q -o /tmp/awscliv2.zip
                    - BINARY=/usr/local/aws-cli/v2/current/bin/aws
                    - |
                      # If the binary exists, update it
                      if [ -x $BINARY ]; then
                          echo Updating awscli v2
                          ./aws/install --update
                      else
                          echo Installing awscli v2
                          ./aws/install
                      fi
                    # Install CloudWatch Agent
                    - ARCH=$(arch)
                    - |
                      if [ "$ARCH" = "arm64" ]; then
                          curl https://amazoncloudwatch-agent-${AWS::Region}.s3.${AWS::Region}.amazonaws.com/redhat/arm64/latest/amazon-cloudwatch-agent.rpm -o /tmp/amazon-cloudwatch-agent.rpm
                      else # x86_64
                          curl https://amazoncloudwatch-agent-${AWS::Region}.s3.${AWS::Region}.amazonaws.com/redhat/amd64/latest/amazon-cloudwatch-agent.rpm -o /tmp/amazon-cloudwatch-agent.rpm
                      fi
                    - rpm -U /tmp/amazon-cloudwatch-agent.rpm

                    # Download all files from S3 bucket
                    - aws s3 cp s3://${EC2RequiredFilesBucket}/ec2-files/ /usr/bin/validation-pipeline/ --recursive

                    # Enable CloudWatch Agent
                    - mv /usr/bin/validation-pipeline/amazon-cloudwatch-agent.json /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json
                    - systemctl enable amazon-cloudwatch-agent
                    - systemctl start amazon-cloudwatch-agent

                    # Enable SQS Poller Service
                    # Replaces the placeholder ("") with actual environment variables
                    - sed -i 's/""/av_scan_mode=${AvScanMode} resource_suffix=${ResourceSuffix} region=${AWS::Region}/g' /usr/bin/validation-pipeline/sqs_poller.service
                    - mv /usr/bin/validation-pipeline/sqs_poller.service /etc/systemd/system/sqs_poller.service
                    - systemctl enable sqs_poller.service
                    - systemctl start sqs_poller.service

  # ImageBuilderTestComponent:
  #   Type: AWS::ImageBuilder::Component
  #   Properties:
  #     Name: !Sub test-component-${ResourceSuffix}
  #     Description: Dummy description
  #     #############################################
  #     # Update Version and ChangeDescription when any changes are made to this resource #
  #     Version: "1.0.0"
  #     ChangeDescription: Initial version
  #     #############################################
  #     Platform: Linux
  #     SupportedOsVersions:
  #       - Red Hat Enterprise Linux 8
  #       - Red Hat Enterprise Linux 9
  #     # KmsKeyId: String
  #     # If there is only one phase, and its name is "test", then the type is TEST. For all other components, the type is BUILD.
  #     Data: |
  #       name: test-image
  #       description: This is hello world testing doc
  #       schemaVersion: 1.0
  #       phases:
  #         - name: test
  #           steps:
  #             - name: HelloWorldStep
  #               action: ExecuteBash
  #               inputs:
  #                 commands:
  #                   - echo "Hello World! Test."

  ImageRecipe:
    Type: AWS::ImageBuilder::ImageRecipe
    Properties:
      Name: !Sub image-recipe-${ResourceSuffix}
      Version: !Ref SemVer
      # Description: Testing ec2 scanner recipe
      ParentImage: !Ref ParentImage
      # WorkingDirectory: String # The default path is `/tmp`
      AdditionalInstanceConfiguration:
        SystemsManagerAgent:
          UninstallAfterBuild: false # Set this to `true` to remove SSM Agent after the final image
        # If overriding the user data, add commands to install SSM, unless it is pre-installed on the base image.
        UserDataOverride:
          Fn::Base64: !Sub |
            #!/bin/bash
            export http_proxy=${ProxyServerAddress}:3128
            export https_proxy=${ProxyServerAddress}:3128
            export no_proxy='169.254.169.254,vi2e.io,s3.${AWS::Region}.amazonaws.com'

            # Install SSM Agent
            BYPASS_GPG=$([ ${BypassGpgCheck} = "true" ] && echo "--nogpgcheck" || echo "")
            ARCH=$(arch)
            if [ "$ARCH" = "arm64" ]; then
                yum install -y https://s3.${AWS::Region}.amazonaws.com/amazon-ssm-${AWS::Region}/latest/linux_arm64/amazon-ssm-agent.rpm $BYPASS_GPG
            else # x86_64
                yum install -y https://s3.${AWS::Region}.amazonaws.com/amazon-ssm-${AWS::Region}/latest/linux_amd64/amazon-ssm-agent.rpm $BYPASS_GPG
            fi

            ## Uncomment the below lines if an instance requires internet access
            # cat << EOF > /etc/profile.d/proxy.sh
            # #!/bin/bash
            # export http_proxy=${ProxyServerAddress}:3128
            # export https_proxy=${ProxyServerAddress}:3128
            # export no_proxy='169.254.169.254,vi2e.io,s3.${AWS::Region}.amazonaws.com'
            # EOF
            # chmod 755 /etc/profile.d/proxy.sh
            # /etc/profile.d/proxy.sh

            cat << EOF > /etc/profile.d/set_env.sh
            #!/bin/bash
            export av_scan_mode=${AvScanMode}
            export resource_suffix=${ResourceSuffix}
            export region=${AWS::Region}
            EOF
            chmod 755 /etc/profile.d/set_env.sh
            /etc/profile.d/set_env.sh
      Components:
        - ComponentArn: !Ref BuildComponentPrepareImage
      # BlockDeviceMappings:
      #   - DeviceName: String
      #     Ebs:
      #       DeleteOnTermination: true
      #       Encrypted: true
      #       KmsKeyId: alias/aws/ebs # The default AWS managed key
      #       Iops: 100 # The range is 100-64000
      #       SnapshotId: String
      #       VolumeType: gp3 # standard | io1 | io2 | gp2 | gp3 | sc1 | st1
      #       Throughput: 125 # For gp3 volumes only; the range is 125–1000 MiB/s
      #       VolumeSize: 30 # The range is 1-16000
      #     NoDevice: "" # Enter an empty string to remove a mapping from the parent image.
      #     VirtualName: String # Manages the instance ephemeral devices.

  ImageBuilderImagePipeline:
    Type: AWS::ImageBuilder::ImagePipeline
    Properties:
      Name: !Sub image-pipeline-${ResourceSuffix}
      Status: ENABLED
      EnhancedImageMetadataEnabled: true # default value is true
      ImageRecipeArn: !Ref ImageRecipe
      DistributionConfigurationArn: !Ref ImageBuilderDistroConfig
      ImageScanningConfiguration:
        ImageScanningEnabled: false # Enable it if Amazon Inspector is activated
      ImageTestsConfiguration:
        ImageTestsEnabled: true
      InfrastructureConfigurationArn: !Ref InfraConfig
      # Schedule:
      #   PipelineExecutionStartCondition: EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE
      #   ScheduleExpression: cron(0 0 * * ? *) # every day at 12:00 AM UTC
      # This Role is for the workflow
      # ExecutionRole: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/imagebuilder.amazonaws.com/AWSServiceRoleForImageBuilder
      # Workflows:
      #   - WorkflowArn: !GetAtt BuildWorkflow.Arn

  ImageBuilderDistroConfig:
    Type: AWS::ImageBuilder::DistributionConfiguration
    Properties:
      Name: !Sub distro-config-${ResourceSuffix}
      Distributions:
        - LaunchTemplateConfigurations:
            - AccountId: !Ref AWS::AccountId
              LaunchTemplateId:
                Fn::ImportValue: !Sub aftac-pipeline-launch-template-name-${ResourceSuffix}
              SetDefaultVersion: true # Set the specified Amazon EC2 launch template as the default launch template for the specified account.
          # AmiDistributionConfiguration:
          #   Name: String
          #   Description: String
          #   KmsKeyId: String
          #   # LaunchPermissionConfiguration: LaunchPermissionConfiguration
          #   TargetAccountIds:
          #     - String
          Region: !Ref AWS::Region

  EC2RequiredFilesBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerEnforced
      # LoggingConfiguration:
      #   DestinationBucketName: BucketName
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              KMSMasterKeyID: !GetAtt ImageBuilderKmsKey.Arn
              SSEAlgorithm: aws:kms # Uses aws/s3
            BucketKeyEnabled: true
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        IgnorePublicAcls: true
        BlockPublicPolicy: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      ObjectLockEnabled: true

  EC2RequiredFilesBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref EC2RequiredFilesBucket
      PolicyDocument:
        Statement:
          - Effect: Deny
            Principal: "*"
            Action: s3:*
            Resource:
              - !Sub ${EC2RequiredFilesBucket.Arn}/*
              - !Sub ${EC2RequiredFilesBucket.Arn}
            Condition:
              Bool:
                aws:SecureTransport: false
          - Sid: AllowTls12Only
            Effect: Deny
            Principal: "*"
            Action: s3:*
            Resource:
              - !Sub ${EC2RequiredFilesBucket.Arn}
              - !Sub ${EC2RequiredFilesBucket.Arn}/*
            Condition:
              NumericLessThan:
                s3:TlsVersion: 1.2

  InfraConfig:
    Type: AWS::ImageBuilder::InfrastructureConfiguration
    Properties:
      Name: !Sub infra-config-${ResourceSuffix}
      InstanceMetadataOptions:
        HttpTokens: required
        HttpPutResponseHopLimit: 1
      InstanceProfileName: !Ref ImageBuilderInfraInstanceProfile
      SubnetId: !Ref SubnetId
      SecurityGroupIds:
        - !Ref ImageBuilderInfraSecurityGroup
      TerminateInstanceOnFailure: true # For troubleshooting, set it to false
      InstanceTypes: [t3.small]
      SnsTopicArn: !Ref ImageBuilderNotificationTopic
      # KeyPair: String
      # Logging:
      #   S3Logs:
      #     S3BucketName: String
      #     S3KeyPrefix: String
      # Placement: Placement
      # ResourceTags:
      #   Key: Value

  ImageBuilderInfraSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group for ImageBuilder infra
      SecurityGroupEgress:
        - CidrIp: !Ref OutboundCidrIp
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          Description: Allow outbound traffic on 443
        - CidrIp: !Ref OutboundCidrIp
          IpProtocol: tcp
          FromPort: 3128
          ToPort: 3128
          Description: Allow outbound traffic on 3128
      VpcId: !Ref VpcId

  ImageBuilderInfraInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub ${IamPrefix}-image-builder-infra-instance-profile-${ResourceSuffix}
      Roles: [!Ref ImageBuilderInfraInstanceRole]

  ImageBuilderInfraInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${IamPrefix}-image-builder-infra-instance-role-${ResourceSuffix}
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
        # TODO: Scope it down if possible
        - !Sub arn:${AWS::Partition}:iam::aws:policy/EC2InstanceProfileForImageBuilder
      Policies:
        - PolicyName: S3_Policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: AllowGetObject
                Effect: Allow
                Action: s3:GetObject
                Resource: !Sub ${EC2RequiredFilesBucket.Arn}/*
              - Sid: AllowListBucket
                Effect: Allow
                Action: s3:ListBucket
                Resource: !Sub ${EC2RequiredFilesBucket.Arn}
        - PolicyName: KMS_Policy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Sid: AllowKMS
                Effect: Allow
                Action: kms:Decrypt
                Resource: !GetAtt ImageBuilderKmsKey.Arn

  ImageBuilderNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: ImageBuilder Event Notification
      KmsMasterKeyId: alias/aws/sns

  ImageBuilderNotificationTopicSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref ImageBuilderNotificationTopic
      Protocol: lambda
      Endpoint: !GetAtt AsgInstanceRefreshLambda.Arn

  ImageBuilderNotificationTopicPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref AsgInstanceRefreshLambda
      Principal: sns.amazonaws.com
      SourceArn: !Ref ImageBuilderNotificationTopic

  ImageBuilderKmsKey:
    Type: AWS::KMS::Key
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      Description: KMS key for ImageBuilder pipeline solution
      Enabled: true
      EnableKeyRotation: true
      PendingWindowInDays: 30
      KeyPolicy:
        Version: 2012-10-17
        Statement:
          - Sid: Allow administration of the key via IAM policies
            Effect: Allow
            Principal:
              AWS: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:root
            NotAction:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:CreateGrant
            Resource: "*"
          - Sid: Allow use of the key only for AWS via IAM policies
            Effect: Allow
            Principal:
              AWS: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:root
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:CreateGrant
            Resource: "*"
            # Condition:
            #   StringEquals:
            #     kms:CallerAccount: !Ref AWS::AccountId
            #     kms:ViaService:
            #       - !Sub s3.${AWS::Region}.amazonaws.com
            #       - !Sub sns.${AWS::Region}.amazonaws.com

          # - Sid: Allow logs service principal to use the key
          #   Effect: Allow
          #   Principal:
          #     Service: !Sub logs.${AWS::Region}.amazonaws.com
          #   Action:
          #     - kms:Encrypt
          #     - kms:Decrypt
          #     - kms:ReEncrypt*
          #     - kms:GenerateDataKey*
          #     - kms:DescribeKey
          #   Resource: "*"
          #   Condition:
          #     ArnEquals:
          #       kms:EncryptionContext:aws:logs:arn:
          #         - !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${ResourceSuffix}-Lambda
          # - Sid: Allow service principal to use the key
          #   Effect: Allow
          #   Principal:
          #     Service:
          #       - events.amazonaws.com
          #   Action:
          #     - kms:GenerateDataKey
          #     - kms:Decrypt
          #   Resource: "*"

  # BuildWorkflow:
  #   Type: AWS::ImageBuilder::Workflow
  #   Properties:
  #     Name: !Sub ${ResourceSuffix}-build-workflow
  #     Type: BUILD # BUILD | TEST | DISTRIBUTION
  #     # KmsKeyId: String
  #     #############################################
  #     # Update Version and ChangeDescription when any changes are made to this resource #
  #     Version: "1.0.0"
  #     ChangeDescription: Initial version
  #     #############################################
  #     Data: |
  #       name: build-image
  #       description: Workflow to build an AMI
  #       schemaVersion: 1.0

  #       steps:
  #         - name: LaunchBuildInstance
  #           action: LaunchInstance
  #           onFailure: Abort
  #           inputs:
  #             waitFor: "ssmAgent"

  #         - name: ApplyBuildComponents
  #           action: ExecuteComponents
  #           onFailure: Abort
  #           inputs:
  #             instanceId.$: "$.stepOutputs.LaunchBuildInstance.instanceId"

  #         - name: InventoryCollection
  #           action: CollectImageMetadata
  #           onFailure: Abort
  #           if:
  #             and:
  #               - stringEquals: "AMI"
  #                 value: "$.imagebuilder.imageType"
  #               - booleanEquals: true
  #                 value: "$.imagebuilder.collectImageMetadata"
  #           inputs:
  #             instanceId.$: "$.stepOutputs.LaunchBuildInstance.instanceId"

  #         - name: RunSanitizeScript
  #           action: SanitizeInstance
  #           onFailure: Abort
  #           if:
  #             and:
  #               - stringEquals: "AMI"
  #                 value: "$.imagebuilder.imageType"
  #               - not:
  #                   stringEquals: "Windows"
  #                   value: "$.imagebuilder.platform"
  #           inputs:
  #             instanceId.$: "$.stepOutputs.LaunchBuildInstance.instanceId"

  #         - name: CreateOutputAMI
  #           action: CreateImage
  #           onFailure: Abort
  #           if:
  #             stringEquals: "AMI"
  #             value: "$.imagebuilder.imageType"
  #           inputs:
  #             instanceId.$: "$.stepOutputs.LaunchBuildInstance.instanceId"

  #         - name: TerminateBuildInstance
  #           action: TerminateInstance
  #           onFailure: Continue
  #           inputs:
  #             instanceId.$: "$.stepOutputs.LaunchBuildInstance.instanceId"

  #       outputs:
  #         - name: "ImageId"
  #           value: "$.stepOutputs.CreateOutputAMI.imageId"

  # TestWorkflow:
  #   Type: AWS::ImageBuilder::Workflow
  #   Properties:
  #     Name: !Sub ${ResourceSuffix}-test-workflow
  #     # Description: ec2-scanner-workflow description
  #     Type: TEST
  #     # KmsKeyId: String
  #     #############################################
  #     # Update Version and ChangeDescription when any changes are made to this resource #
  #     Version: "1.0.0"
  #     ChangeDescription: Initial version
  #     #############################################
  #     Data: |
  #       name: test-image
  #       description: Workflow to test an image
  #       schemaVersion: 1.0

  #       steps:
  #         - name: LaunchTestInstance
  #           action: LaunchInstance
  #           onFailure: Abort
  #           inputs:
  #             waitFor: "ssmAgent"

  #         # - name: CollectImageScanFindings
  #         #   action: CollectImageScanFindings
  #         #   onFailure: Continue
  #         #   if:
  #         #     booleanEquals: true
  #         #     value: "$.imagebuilder.collectImageScanFindings"
  #         #   inputs:
  #         #     instanceId.$: "$.stepOutputs.LaunchTestInstance.instanceId"

  #         - name: ApplyTestComponents
  #           action: ExecuteComponents
  #           onFailure: Abort
  #           inputs:
  #             instanceId.$: "$.stepOutputs.LaunchTestInstance.instanceId"

  #         - name: TerminateTestInstance
  #           action: TerminateInstance
  #           onFailure: Continue
  #           inputs:
  #             instanceId.$: "$.stepOutputs.LaunchTestInstance.instanceId"

  NewAmiImageBuilderTriggerLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub trigger-image-pipeline-with-new-ami-${ResourceSuffix}
      Handler: index.handler
      Role: !GetAtt NewAmiImageBuilderTriggerLambdaRole.Arn
      Runtime: python3.11
      Timeout: 300
      Environment:
        Variables:
          PIPELINE_ARN: !GetAtt ImageBuilderImagePipeline.Arn
          SOURCE_ACCOUNT: !Ref SourceAccountId
          STACK_NAME: !Ref AWS::StackName
          IMAGE_NAME_PATTERN: !Ref ImageNamePattern
          REQUIRED_DESCRIPTION_ITEMS:
            !Join [",", !Ref RequiredImageDescriptionPattern]

      Code:
        ZipFile: |
          import json
          import logging
          import os
          from datetime import datetime

          import boto3  # type: ignore

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # Initialize AWS clients
          EC2 = boto3.client("ec2")
          IMAGE_BUILDER = boto3.client("imagebuilder")
          CFN = boto3.client("cloudformation")

          # Environment variables
          STACK_NAME = os.environ["STACK_NAME"]
          SOURCE_ACCOUNT = os.environ["SOURCE_ACCOUNT"]
          PIPELINE_ARN = os.environ["PIPELINE_ARN"]
          IMAGE_NAME_PATTERN = os.environ["IMAGE_NAME_PATTERN"]
          REQUIRED_DESCRIPTION_ITEMS = os.environ["REQUIRED_DESCRIPTION_ITEMS"].split(",")


          def handler(event, context):
              logger.info(f"Event: {json.dumps(event)}")

              # Get current stack parameters
              current_parameters = get_stack_parameters()
              current_base_ami = current_parameters.get("ParentImage")
              current_semver = current_parameters.get("SemVer")

              # Get latest AMI
              latest_image_id = get_latest_image_id()
              if not latest_image_id:
                  return

              # Check if this is a new AMI
              if latest_image_id == current_base_ami:
                  logger.info(f"No new AMI found. Current AMI: {current_base_ami}")
                  return

              logger.info(f"Found new AMI: {latest_image_id}")

              # Increment version
              new_semver = increment_version(current_semver)
              logger.info(f"Incrementing version from {current_semver} to {new_semver}")

              # Update CloudFormation stack
              update_cloudformation_stack(current_parameters, latest_image_id, new_semver)

              # Wait for stack update to complete
              wait_for_stack_update()

              logger.info(f"Updated stack: {STACK_NAME} with new AMI: {latest_image_id}")

              # Start the Image Builder pipeline
              start_image_pipeline()

              logger.info(f"Started image builder pipeline with new parent image: {latest_image_id}")


          def get_stack_parameters() -> dict[str, str]:
              stack_params = CFN.describe_stacks(StackName=STACK_NAME)["Stacks"][0]["Parameters"]
              return {
                  param["ParameterKey"]: param["ParameterValue"]
                  for param in stack_params
              }


          def get_latest_image_id() -> dict | None:
              paginator = EC2.get_paginator("describe_images")
              page_iterator = paginator.paginate(
                  Owners=[SOURCE_ACCOUNT],
                  Filters=[
                      {
                          "Name": "state",
                          "Values": ["available"]
                      }
                  ]
              )

              images = [
                  image
                  for page in page_iterator
                  for image in page["Images"]
                  if IMAGE_NAME_PATTERN.lower() in image["Name"].lower() and
                  all(item.lower() in image.get("Description", "").lower()
                      for item in REQUIRED_DESCRIPTION_ITEMS)
              ]

              if not images:
                  logger.info("No AMI found matching both name pattern and description requirements")
                  return None

              # Sort the images by creation date in descending order
              images = sorted(
                  images,
                  key=lambda image: datetime.strptime(image["CreationDate"], "%Y-%m-%dT%H:%M:%S.%fZ"),
                  reverse=True
              )

              latest_image = images[0]
              latest_image_id = latest_image["ImageId"]
              logger.info(f"Found matching AMI: {latest_image_id}")
              logger.info(f"Name: {latest_image['Name']}")
              logger.info(f"Description: {latest_image.get('Description', '')}")
              return latest_image_id


          def increment_version(semver: str) -> str:
              major, minor, patch = map(int, semver.split("."))
              return f"{major}.{minor}.{patch + 1}"


          def update_cloudformation_stack(parameters: dict, new_ami_id: str, new_semver: str):
              # Overwrite the parameters for ParentImage and SemVer
              parameters["ParentImage"] = new_ami_id
              parameters["SemVer"] = new_semver

              # Generate an updated parameter list
              parameter_list = [
                  {
                      "ParameterKey": key,
                      "ParameterValue": value
                  }
                  for key, value in parameters.items()
              ]

              CFN.update_stack(
                  StackName=STACK_NAME,
                  UsePreviousTemplate=True,
                  Parameters=parameter_list,
                  Capabilities=["CAPABILITY_NAMED_IAM"]
              )


          def wait_for_stack_update():
              waiter = CFN.get_waiter("stack_update_complete")
              waiter.wait(
                  StackName=STACK_NAME,
                  WaiterConfig={"Delay": 10, "MaxAttempts": 30}
              )


          def start_image_pipeline():
              IMAGE_BUILDER.start_image_pipeline_execution(
                  imagePipelineArn=PIPELINE_ARN,
              )

  NewAmiImageBuilderTriggerLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/trigger-image-pipeline-with-new-ami-${ResourceSuffix}
      RetentionInDays: 90

  NewAmiImageBuilderTriggerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${IamPrefix}-trigger-image-pipeline-with-new-ami-${ResourceSuffix}
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AllowLogging
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:DescribeLogGroups
                Resource:
                  - !GetAtt NewAmiImageBuilderTriggerLogGroup.Arn
                  - !Sub arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group::log-stream:*
        - PolicyName: ImageBuilderAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - imagebuilder:StartImagePipelineExecution
                  - imagebuilder:UpdateImagePipeline
                  - imagebuilder:GetImagePipeline
                  - imagebuilder:CreateComponent
                  - imagebuilder:DeleteComponent
                  - imagebuilder:GetComponent
                  - imagebuilder:TagResource
                  - imagebuilder:CreateImageRecipe
                  - imagebuilder:GetImageRecipe
                  - imagebuilder:DeleteImageRecipe
                  - imagebuilder:GetDistributionConfiguration
                  - imagebuilder:GetInfrastructureConfiguration
                Resource:
                  - !GetAtt ImageBuilderImagePipeline.Arn
                  - !GetAtt InfraConfig.Arn
                  - !GetAtt ImageBuilderDistroConfig.Arn
                  - !Sub arn:${AWS::Partition}:imagebuilder:${AWS::Region}:${AWS::AccountId}:component/*
                  - !Sub arn:${AWS::Partition}:imagebuilder:${AWS::Region}:${AWS::AccountId}:image-recipe/*
                  - !Sub arn:${AWS::Partition}:imagebuilder:${AWS::Region}:${AWS::AccountId}:distribution-configuration/*
                  - !Sub arn:${AWS::Partition}:imagebuilder:${AWS::Region}:${AWS::AccountId}:infrastructure-configuration/*
                  - !Sub arn:${AWS::Partition}:imagebuilder:${AWS::Region}:${AWS::AccountId}:image/*
        - PolicyName: CloudFormationAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStacks
                  - cloudformation:UpdateStack
                Resource: !Sub arn:${AWS::Partition}:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/${AWS::StackName}/*
        - PolicyName: S3Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: !Sub arn:${AWS::Partition}:s3:::${TemplateBucketName}/*
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource: !Sub arn:${AWS::Partition}:s3:::${TemplateBucketName}
        - PolicyName: LambdaAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:UpdateFunctionConfiguration
                Resource:
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:trigger-image-pipeline-with-new-ami-${ResourceSuffix}
        - PolicyName: KMSAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - kms:DescribeKey
                  - kms:GenerateDataKey
                Resource: !GetAtt ImageBuilderKmsKey.Arn
        - PolicyName: IAMAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - iam:PutRolePolicy
                  - iam:DeleteRolePolicy
                  - iam:GetRole
                Resource: !Sub arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${IamPrefix}-trigger-image-pipeline-with-new-ami-${ResourceSuffix}
        - PolicyName: EC2Access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeImages
                  - ec2:DescribeSubnets
                  - ec2:DescribeVpcs
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceAccount": !Ref AWS::AccountId

  NewAmiImageBuilderTriggerScheduleRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub trigger-image-pipeline-with-new-ami-${ResourceSuffix}
      Description: "Periodically check for new AMIs"
      ScheduleExpression: !Ref ImageCheckFrequency
      State: ENABLED
      Targets:
        - Arn: !GetAtt NewAmiImageBuilderTriggerLambda.Arn
          Id: "NewAmiImageBuilderTrigger"

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref NewAmiImageBuilderTriggerLambda
      Principal: events.amazonaws.com
      SourceArn: !GetAtt NewAmiImageBuilderTriggerScheduleRule.Arn

  CopyEC2RequiredFilesLambdaFunctionLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/copy-ec2-required-files-${ResourceSuffix}
      RetentionInDays: 90

  CopyEC2RequiredFilesRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${IamPrefix}-copy-ec2-required-files-role-${ResourceSuffix}
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AllowLogging
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !GetAtt CopyEC2RequiredFilesLambdaFunctionLogGroup.Arn
        - PolicyName: KMSAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - kms:DescribeKey
                  - kms:GenerateDataKey
                Resource: !GetAtt ImageBuilderKmsKey.Arn
        - PolicyName: S3AccessPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                Resource:
                  - !Sub arn:${AWS::Partition}:s3:::${TemplateBucketName}
                  - !Sub arn:${AWS::Partition}:s3:::${EC2RequiredFilesBucket}
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource: !Sub arn:${AWS::Partition}:s3:::${TemplateBucketName}/*
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub arn:${AWS::Partition}:s3:::${EC2RequiredFilesBucket}/*

  CopyEC2RequiredFilesCustomResource:
    Type: Custom::CopyEC2Files
    Properties:
      ServiceTimeout: 60
      ServiceToken: !GetAtt CopyEC2RequiredFilesFunction.Arn
      SourceBucket: !Ref TemplateBucketName
      DestinationBucket: !Ref EC2RequiredFilesBucket
      SourcePrefix: !Sub ${TemplatePrefix}/ec2-files/
      DestinationPrefix: ec2-files/

  CopyEC2RequiredFilesFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub copy-ec2-required-files-${ResourceSuffix}
      Handler: index.handler
      Role: !GetAtt CopyEC2RequiredFilesRole.Arn
      Runtime: python3.11
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          S3 = boto3.client('s3')

          def copy_files(source_bucket, dest_bucket, source_prefix, dest_prefix):
              try:
                  paginator = S3.get_paginator('list_objects_v2')
                  copied_files = []

                  for page in paginator.paginate(Bucket=source_bucket, Prefix=source_prefix):
                      if 'Contents' in page:
                          for obj in page['Contents']:
                              source_key = obj['Key']

                              # Skip if this is a folder placeholder
                              if source_key.endswith('/'):
                                  continue

                              # Calculate the relative path from source_prefix
                              relative_path = source_key[len(source_prefix):]

                              # Construct new destination key with dest_prefix
                              dest_key = f"{dest_prefix.rstrip('/')}/{relative_path}"

                              copy_source = {
                                  'Bucket': source_bucket,
                                  'Key': source_key
                              }

                              S3.copy_object(
                                  CopySource=copy_source,
                                  Bucket=dest_bucket,
                                  Key=dest_key
                              )

                              copied_files.append({
                                  'source': f"{source_bucket}/{source_key}",
                                  'destination': f"{dest_bucket}/{dest_key}"
                              })
                              logger.info(f"Copied {source_key} to {dest_bucket}/{dest_key}")

                  return copied_files

              except Exception as e:
                  logger.error(f"Error copying files: {str(e)}")
                  raise

          def handler(event, context):
              try:
                  logger.info(f"Received event: {event}")

                  # Get parameters from the event
                  props = event['ResourceProperties']
                  source_bucket = props['SourceBucket']
                  dest_bucket = props['DestinationBucket']
                  source_prefix = props['SourcePrefix']
                  dest_prefix = props['DestinationPrefix']

                  if event['RequestType'] in ['Create', 'Update']:
                      copied_files = copy_files(
                          source_bucket,
                          dest_bucket,
                          source_prefix,
                          dest_prefix
                      )
                      logger.info(f"Files copied successfully: {copied_files}")

                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

              except Exception as e:
                  error_message = f"Error: {str(e)}"
                  logger.error(error_message)
                  cfnresponse.send(event, context, cfnresponse.FAILED,
                      {'Error': error_message})

  AsgInstanceRefreshLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      LogGroupName: !Sub /aws/lambda/refresh-asg-on-image-completion-${ResourceSuffix}
      RetentionInDays: 90

  AsgInstanceRefreshLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub ${IamPrefix}-refresh-asg-on-image-completion-${ResourceSuffix}
      PermissionsBoundary: !Ref PermissionsBoundaryPolicyArn
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AllowLogging
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !GetAtt AsgInstanceRefreshLogGroup.Arn
        - PolicyName: ASGAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - autoscaling:StartInstanceRefresh
                  - autoscaling:DescribeAutoScalingGroups
                Resource:
                  Fn::Sub:
                    - arn:${AWS::Partition}:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/${AsgName}
                    - AsgName: !ImportValue
                        Fn::Sub: aftac-pipeline-asg-name-${ResourceSuffix}
              - Effect: Allow
                Action:
                  - autoscaling:DescribeInstanceRefreshes
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceAccount": !Ref AWS::AccountId
        - PolicyName: SNSAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: sns:Publish
                Resource: !Ref AsgInstanceRefreshNotificationTopic

  AsgInstanceRefreshLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub refresh-asg-on-image-completion-${ResourceSuffix}
      Handler: index.handler
      Role: !GetAtt AsgInstanceRefreshLambdaRole.Arn
      Runtime: python3.11
      Timeout: 900
      Environment:
        Variables:
          ASG_NAME:
            Fn::ImportValue: !Sub aftac-pipeline-asg-name-${ResourceSuffix}
          NOTIFICATION_TOPIC_ARN: !Ref AsgInstanceRefreshNotificationTopic

      Code:
        ZipFile: |
          import boto3
          import json
          import logging
          import os
          import time
          from datetime import datetime

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          ASG = boto3.client('autoscaling')
          SNS = boto3.client('sns')
          ASG_NAME = os.environ['ASG_NAME']
          NOTIFICATION_TOPIC_ARN = os.environ['NOTIFICATION_TOPIC_ARN']

          def start_instance_refresh():
              response = ASG.start_instance_refresh(
                  AutoScalingGroupName=ASG_NAME,
                  Strategy='Rolling',
                  Preferences={
                      'MinHealthyPercentage': 50
                  }
              )
              refresh_id = response['InstanceRefreshId']
              logger.info(f"Started instance refresh for ASG {ASG_NAME}: {refresh_id}")
              return refresh_id

          def wait_for_refresh_completion(refresh_id):
              while True:
                  response = ASG.describe_instance_refreshes(
                      AutoScalingGroupName=ASG_NAME,
                      InstanceRefreshIds=[refresh_id]
                  )

                  status = response['InstanceRefreshes'][0]['Status']
                  logger.info(f"Instance refresh status: {status}")

                  if status in ['Successful', 'Failed', 'Cancelled', 'RollbackSuccessful', 'RollbackFailed']:
                      return status
                  time.sleep(10)

          def send_notification(ami_info, refresh_status):
              if not NOTIFICATION_TOPIC_ARN:
                  logger.info("No notification topic provided, skipping notification")
                  return

              timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
              message = (
                  f"Image Builder Pipeline Update - {timestamp}\n\n"
                  f"New Image Builder Image Created:\n"
                  f"- AMI ID: {ami_info['image']}\n"
                  f"- AMI Name: {ami_info.get('name', 'N/A')}\n\n"
                  f"Auto Scaling Group Update:\n"
                  f"- ASG Name: {ASG_NAME}\n"
                  f"- Refresh Status: {refresh_status}\n"
              )

              SNS.publish(
                  TopicArn=NOTIFICATION_TOPIC_ARN,
                  Subject=f"Image Builder Pipeline Update and ASG Instance Refresh",
                  Message=message
              )
              logger.info("Notification sent successfully")


          def handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")

              try:
                  # Parse SNS message
                  message = json.loads(event['Records'][0]['Sns']['Message'])

                  # Check if this is an AMI build and it's available
                  if (message.get('state', {}).get('status') == 'AVAILABLE' and
                      'outputResources' in message and
                      'amis' in message['outputResources']):

                      ami_info = message['outputResources']['amis'][0]
                      logger.info(f"New AMI created: {ami_info['image']} - {ami_info.get('name')}")

                      # Start instance refresh
                      refresh_id = start_instance_refresh()

                      # Wait for refresh completion
                      refresh_status = wait_for_refresh_completion(refresh_id)
                      logger.info(f"Instance refresh completed with status: {refresh_status}")

                      # Send notification
                      send_notification(ami_info, refresh_status)

                  else:
                      logger.info("Image is not in AVAILABLE state or not an AMI build")

              except Exception as e:
                  logger.error(f"Error processing event: {str(e)}")
                  raise

  AsgInstanceRefreshNotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: ImageBuilder Event Notification
      KmsMasterKeyId: alias/aws/sns

  AsgInstanceRefreshNotificationTopicSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref AsgInstanceRefreshNotificationTopic
      Protocol: email
      Endpoint: !Ref EmailEndPoint
